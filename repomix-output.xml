This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
color_data/
  green_data.csv
  orange_data.csv
  purple_data.csv
  red_data.csv
  white_data.csv
  yellow_data.csv
color_mean_std/
  green_stats.csv
  orange_stats.csv
  purple_stats.csv
  red_stats.csv
  white_stats.csv
  yellow_stats.csv
color_mult_gaussian/
  green.json
  orange.json
  purple.json
  red.json
  white.json
  yellow.json
src/
  color_matching.py
  constants.py
  drive_system.py
  fire_extinguisher.py
  mission_control.py
  navigation.py
  sensor_system.py
  siren_controller.py
utils/
  brick.py
  dummy.py
  filters.py
  remote.py
  rmi.py
  sound.py
  telemetry.py
.gitignore
main.py
README.md
structured_main.py
track_testing.py
unknown_color.csv
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="color_data/green_data.csv">
73,129,11
75,133,13
74,132,12
76,136,14
74,132,13
73,130,11
75,133,12
70,129,12
71,128,12
71,128,14
70,127,14
70,126,12
68,127,13
69,124,11
66,121,10
67,123,12
70,127,11
68,122,10
69,122,12
70,126,14
68,123,11
70,125,12
71,128,14
71,127,12
70,125,11
69,127,13
69,127,12
68,124,10
70,126,12
69,124,12
71,128,14
71,128,13
71,126,12
68,126,11
70,125,11
68,124,13
65,123,12
70,124,14
67,122,13
70,126,13
67,120,11
66,121,12
66,121,11
67,123,12
68,125,13
66,122,10
67,123,12
68,121,12
64,118,10
66,121,11
68,122,12
70,127,14
69,124,11
72,126,13
64,120,10
68,124,12
66,122,12
69,123,11
71,126,12
68,124,14
67,122,11
70,124,12
67,123,12
71,125,13
67,124,13
65,121,10
69,125,13
67,124,11
67,121,11
66,121,12
</file>

<file path="color_data/orange_data.csv">
185,59,24
185,59,25
187,57,22
184,59,24
185,57,21
183,60,24
184,56,21
184,57,24
191,61,27
185,57,23
182,57,23
182,56,22
184,54,21
186,59,25
183,57,24
188,57,21
186,58,23
190,57,23
190,61,25
193,61,24
187,60,23
189,58,23
189,59,25
185,57,24
191,60,22
194,62,25
197,61,23
198,63,26
199,61,26
194,61,23
200,63,25
199,60,24
202,63,25
203,64,26
201,64,26
202,63,23
204,62,25
202,61,24
201,62,25
204,64,23
202,63,26
203,64,26
202,61,24
201,61,24
199,62,25
201,61,24
203,62,25
206,64,26
204,64,26
204,63,24
206,62,25
207,65,26
205,64,26
207,63,25
207,65,26
205,64,26
213,65,26
214,66,26
208,63,24
208,63,24
213,67,27
215,66,26
217,66,25
219,68,28
217,66,25
214,64,25
205,64,27
201,61,24
205,63,24
206,63,25
214,66,26
214,65,26
218,66,26
213,67,27
215,68,28
210,67,27
205,64,25
204,65,26
201,62,24
191,62,26
</file>

<file path="color_data/purple_data.csv">
48,39,34
47,39,35
44,38,34
47,39,34
46,39,33
48,39,35
49,41,36
47,40,35
48,39,32
45,37,33
46,39,34
46,37,31
43,37,32
43,36,33
46,40,34
46,37,32
43,37,33
47,38,34
44,37,34
47,39,34
44,37,34
44,36,33
48,40,35
49,39,34
50,41,35
49,40,36
49,41,37
47,38,33
49,40,34
49,40,35
47,40,36
46,38,34
45,36,33
46,39,34
46,38,35
46,37,32
46,38,34
44,37,34
42,35,32
45,36,32
45,36,32
44,35,31
43,35,31
45,38,34
46,36,34
44,36,33
46,39,34
45,35,32
44,37,33
45,38,33
45,37,32
43,35,33
44,36,31
42,37,34
43,36,33
47,38,33
46,38,32
46,35,31
47,38,35
47,39,35
47,37,32
47,40,35
48,38,33
46,38,35
48,40,34
47,38,32
45,36,33
48,38,33
49,41,36
47,38,33
</file>

<file path="color_data/red_data.csv">
83,17,7
87,17,6
84,16,6
81,15,5
80,16,6
80,16,5
83,17,8
83,17,7
85,18,5
84,18,7
82,15,5
86,19,7
84,15,5
86,16,8
85,18,7
85,17,6
87,16,5
87,18,8
86,16,7
87,15,5
86,15,5
88,15,6
89,18,7
90,18,6
87,16,6
88,17,7
87,18,7
85,14,5
88,16,6
87,16,6
88,17,7
92,19,7
88,16,6
88,15,4
89,18,4
90,18,7
86,17,6
87,17,5
86,16,6
89,17,6
90,18,7
85,16,6
83,15,5
84,14,5
86,16,5
84,14,4
0,16,7
91,19,8
88,15,4
88,18,6
</file>

<file path="color_data/white_data.csv">
228,262,108
229,263,109
230,263,107
226,261,106
231,263,108
234,265,108
236,269,111
234,268,107
233,269,109
238,268,110
223,258,105
230,263,108
244,274,112
242,272,112
246,274,112
245,274,113
246,274,113
242,273,110
238,269,111
233,265,108
232,264,109
233,266,107
236,269,110
234,264,109
227,262,105
230,263,107
227,261,108
224,257,105
221,255,104
222,255,104
219,254,105
222,256,106
224,257,105
227,259,106
223,259,107
219,254,104
221,255,104
220,253,104
215,251,103
217,251,102
211,246,101
210,244,99
209,242,99
207,241,101
200,233,96
200,235,95
200,234,97
0,243,100
206,241,100
206,240,97
208,244,101
212,245,99
219,253,104
219,252,103
219,253,105
216,251,104
220,254,105
218,251,104
217,252,104
217,251,102
220,253,104
219,254,105
220,255,104
223,256,104
219,252,102
223,256,104
222,256,106
227,259,105
221,254,104
223,256,105
222,256,104
231,263,108
227,260,108
228,260,106
231,263,107
229,261,107
233,265,108
243,273,113
</file>

<file path="color_data/yellow_data.csv">
230,136,13
183,161,16
191,165,15
206,176,16
218,185,16
231,193,16
244,201,19
255,205,18
266,206,18
272,201,19
273,199,18
271,202,18
271,207,19
264,204,18
267,204,16
270,206,19
269,203,17
267,205,18
268,207,20
267,205,19
270,207,20
268,203,17
272,206,19
270,204,20
271,203,17
272,202,20
270,202,19
272,203,17
272,202,18
272,203,18
270,205,21
272,205,20
272,205,19
273,203,19
271,201,17
270,199,19
271,200,20
271,201,20
272,198,17
272,196,19
272,196,21
273,196,18
273,198,19
273,201,20
272,200,19
204,176,16
230,195,16
248,205,18
256,210,19
277,212,17
274,212,21
277,211,22
276,206,19
277,210,21
275,204,18
276,205,20
276,207,18
277,202,18
272,187,18
263,170,15
257,162,17
253,156,16
245,149,15
245,146,14
245,149,16
249,155,16
259,162,14
263,169,17
270,182,18
272,184,17
270,182,18
268,179,18
267,173,16
251,210,19
256,213,20
258,213,20
256,215,20
257,212,19
258,214,19
255,212,20
258,213,22
255,211,19
253,211,19
257,214,24
256,215,22
254,212,18
261,216,21
259,215,20
257,212,19
263,215,22
260,214,19
264,217,20
261,213,20
263,217,20
260,215,21
254,212,20
227,199,21
226,199,20
224,194,17
226,197,19
224,196,19
225,197,19
228,197,18
233,202,21
238,205,19
237,203,19
235,203,20
234,202,21
234,202,20
231,199,19
232,200,18
230,200,19
224,195,18
231,202,20
227,198,20
232,201,20
225,197,20
228,197,18
228,199,20
228,199,20
222,193,15
224,195,19
227,198,18
221,194,20
226,198,20
225,197,19
221,192,18
219,193,19
215,191,18
224,196,18
222,193,19
224,196,19
223,195,19
224,197,20
225,196,18
220,194,19
221,193,18
220,191,18
221,195,20
223,195,19
219,193,19
225,197,19
225,196,19
230,200,21
227,199,20
226,196,17
223,194,18
226,198,21
220,193,19
220,192,18
222,195,19
226,197,21
227,198,19
224,195,19
224,196,19
225,196,19
</file>

<file path="color_mean_std/green_stats.csv">
0.33503, 0.00388
0.60670, 0.00483
0.05828, 0.00474
</file>

<file path="color_mean_std/orange_stats.csv">
0.69737, 0.00569
0.21640, 0.00300
0.08623, 0.00370
</file>

<file path="color_mean_std/purple_stats.csv">
0.39188, 0.00740
0.32257, 0.00442
0.28555, 0.00678
</file>

<file path="color_mean_std/red_stats.csv">
0.77716, 0.11314
0.16280, 0.07737
0.06003, 0.03636
</file>

<file path="color_mean_std/white_stats.csv">
0.37702, 0.04334
0.44194, 0.03064
0.18105, 0.01278
</file>

<file path="color_mean_std/yellow_stats.csv">
0.53318, 0.02515
0.42640, 0.02285
0.04042, 0.00340
</file>

<file path="color_mult_gaussian/green.json">
{
    "color": "green",
    "mean": [
        0.27064425770308137,
        0.48997198879551757,
        0.0471148459383753
    ],
    "covariance": [
        [
            0.00010185284685059022,
            0.00012415673856925553,
            2.072462972116953e-05
        ],
        [
            0.00012415673856925553,
            0.00018137314601885098,
            2.987861811391224e-05
        ],
        [
            2.072462972116953e-05,
            2.987861811391224e-05,
            2.0724629721169507e-05
        ]
    ]
}
</file>

<file path="color_mult_gaussian/orange.json">
{
    "color": "orange",
    "mean": [
        0.7823529411764704,
        0.2427450980392154,
        0.09671568627450966
    ],
    "covariance": [
        [
            0.0017122917670418878,
            0.0004781023851585807,
            0.0001694577061402869
        ],
        [
            0.0004781023851585807,
            0.00015713527903094728,
            6.25465376023827e-05
        ],
        [
            0.0001694577061402869,
            6.25465376023827e-05,
            3.852218474880643e-05
        ]
    ]
}
</file>

<file path="color_mult_gaussian/purple.json">
{
    "color": "purple",
    "mean": [
        0.1803921568627449,
        0.148515406162465,
        0.1314285714285714
    ],
    "covariance": [
        [
            5.616568878190664e-05,
            3.878107082560218e-05,
            2.1173573151909243e-05
        ],
        [
            3.878107082560218e-05,
            4.2312122348228897e-05,
            2.666278219159218e-05
        ],
        [
            2.1173573151909243e-05,
            2.666278219159218e-05,
            2.8859739405850447e-05
        ]
    ]
}
</file>

<file path="color_mult_gaussian/red.json">
{
    "color": "red",
    "mean": [
        0.33113725490196094,
        0.06478431372549019,
        0.0236078431372549
    ],
    "covariance": [
        [
            0.00239290068968764,
            3.940713540318087e-05,
            -1.708605010631702e-05
        ],
        [
            3.940713540318087e-05,
            2.776953918822431e-05,
            1.3960093841458152e-05
        ],
        [
            -1.708605010631702e-05,
            1.3960093841458152e-05,
            1.8510933785278807e-05
        ]
    ]
}
</file>

<file path="color_mult_gaussian/white.json">
{
    "color": "white",
    "mean": [
        0.8685771744595269,
        1.0089994972347909,
        0.4133232780291598
    ],
    "covariance": [
        [
            0.011688908297904838,
            0.0022031076702357,
            0.0008659801047344304
        ],
        [
            0.0022031076702357,
            0.001449236397333284,
            0.0005757743474006451
        ],
        [
            0.0008659801047344304,
            0.0005757743474006451,
            0.00024299934334536403
        ]
    ]
}
</file>

<file path="color_mult_gaussian/yellow.json">
{
    "color": "yellow",
    "mean": [
        0.9693061840120658,
        0.7740321769733526,
        0.07332830568124671
    ],
    "covariance": [
        [
            0.007562185950622157,
            0.001614444911911146,
            7.343424890026063e-05
        ],
        [
            0.001614444911911146,
            0.003286545958495951,
            0.00027302408661935385
        ],
        [
            7.343424890026063e-05,
            0.00027302408661935385,
            4.5128027045651796e-05
        ]
    ]
}
</file>

<file path="src/color_matching.py">
import json
import csv
import math

# Attemting to replace the np dependency with our own functions

COLOR_DATA_DIR = "../color_data/"

# Dictionary mapping color names to their respective CSV files
COLOR_DATA = {
    "white": COLOR_DATA_DIR + "white_data.csv",  # Hallway
    "purple": COLOR_DATA_DIR + "purple_data.csv",  # Burning room
    "yellow": COLOR_DATA_DIR + "yellow_data.csv",  # Room to avoid
    "green": COLOR_DATA_DIR + "green_data.csv",  # Green Card
    "red": COLOR_DATA_DIR + "red_data.csv",  # Red Card
    "orange": COLOR_DATA_DIR + "orange_data.csv",  # Entrance line
}


def read_csv_to_list(filename):
    """
    Reads RGB values from a CSV file into a list of lists.

    Parameters:
        filename (str): Path to the CSV file containing RGB values.

    Returns:
        list: A list of lists containing RGB values as floats.
    """
    rgb_values = []
    with open(filename, "r") as file:
        csv_reader = csv.reader(file)
        for row in csv_reader:
            # Convert string values to float
            rgb_values.append([float(val) for val in row])
    return rgb_values


def compute_mean(data):
    """
    Computes the mean vector for a list of vectors.

    Parameters:
        data (list): List of vectors (each vector is a list of numbers).

    Returns:
        list: Mean vector.
    """
    if not data:
        return []

    num_features = len(data[0])
    mean = [0] * num_features

    for vector in data:
        for i in range(num_features):
            mean[i] += vector[i]

    return [val / len(data) for val in mean]


def compute_covariance(data, mean):
    """
    Computes the covariance matrix for a list of vectors.

    Parameters:
        data (list): List of vectors (each vector is a list of numbers).
        mean (list): Mean vector for the data.

    Returns:
        list: Covariance matrix as a list of lists.
    """
    n = len(data)
    if n <= 1:
        return [[0] * len(mean) for _ in range(len(mean))]

    dim = len(mean)
    cov = [[0] * dim for _ in range(dim)]

    for vector in data:
        for i in range(dim):
            for j in range(dim):
                cov[i][j] += (vector[i] - mean[i]) * (vector[j] - mean[j])

    for i in range(dim):
        for j in range(dim):
            cov[i][j] /= n - 1

    return cov


def multivariate_gaussian(filename):
    """
    Computes the mean vector and covariance matrix for RGB values.

    Parameters:
        filename (str): Path to the CSV file containing RGB values.
            or
        filename (list): list of lists of rgb values

    Returns:
        tuple: (mean vector, covariance matrix)
    """
    if isinstance(filename, str):
        rgb_values = read_csv_to_list(filename)
    elif isinstance(filename, list):
        rgb_values = filename
    else:
        raise Exception(
            "multivatiate_gaussian() received bad input: \nneeds to be either str (filename) or list"
        )

    # Normalize RGB values to [0,1] range
    rgb_values = [[val / 255.0 for val in row] for row in rgb_values]

    mu = compute_mean(rgb_values)  # Compute mean vector
    sigma = compute_covariance(rgb_values, mu)  # Compute covariance matrix

    return mu, sigma


def save_mult_gaussian(color_name, mu, sigma):
    """
    Saves the mean vector and covariance matrix of a color to a JSON file.

    Parameters:
        color_name (str): Name of the color.
        mu (list): Mean vector.
        sigma (list): Covariance matrix.
    """
    data = {"color": color_name, "mean": mu, "covariance": sigma}

    filepath = "color_mult_gaussian/" + color_name + ".json"
    with open(filepath, "w") as file:
        json.dump(data, file, indent=4)


def save_mult_gaussian_for_all_colors():
    """
    Computes and saves the mean vector and covariance matrix for all colors in COLOR_DATA.
    """
    for color in COLOR_DATA:
        mu, sigma = multivariate_gaussian(COLOR_DATA[color])
        save_mult_gaussian(color, mu, sigma)


def retreive_mult_gaussian(color_name):
    """
    Retrieves the mean vector and covariance matrix of a color from a JSON file.

    Parameters:
        color_name (str): Name of the color.

    Returns:
        tuple: (mean vector as list, covariance matrix as list of lists)
    """
    filepath = "color_mult_gaussian/" + color_name + ".json"

    with open(filepath, "r") as file:
        try:
            data = json.load(file)
            if data["color"] == color_name:
                return data["mean"], data["covariance"]
        except json.JSONDecodeError as e:
            print("Error loading JSON:", e)
            return None, None

    raise ValueError(f"Color '{color_name}' not found in {filepath}")


def test_retreive():
    """
    Tests retrieval of a stored mean vector and covariance matrix against computed values.
    """
    og_mu, og_sig = multivariate_gaussian(COLOR_DATA_DIR + "red_data.csv")
    print("OG MU: ", og_mu)
    print("OG SIGMA: ", og_sig, "\n")

    av, sig = retreive_mult_gaussian("red")
    print("GOT MU: ", av)
    print("GOT SIGMA: ", sig, "\n")

    # Check if values are equal (within a small epsilon for floating-point comparison)
    eps = 1e-6
    mean_equal = all(abs(m1 - m2) < eps for m1, m2 in zip(og_mu, av))

    sigma_equal = True
    for row1, row2 in zip(og_sig, sig):
        if not all(abs(s1 - s2) < eps for s1, s2 in zip(row1, row2)):
            sigma_equal = False
            break

    assert mean_equal
    assert sigma_equal


def matrix_determinant(matrix):
    """
    Compute the determinant of a 3x3 matrix.
    """
    if len(matrix) != 3 or len(matrix[0]) != 3:
        raise ValueError("Only 3x3 matrices are supported")

    a, b, c = matrix[0]
    d, e, f = matrix[1]
    g, h, i = matrix[2]

    return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)


def matrix_inverse(matrix):
    """
    Compute the inverse of a 3x3 matrix.
    """
    if len(matrix) != 3 or len(matrix[0]) != 3:
        raise ValueError("Only 3x3 matrices are supported")

    det = matrix_determinant(matrix)
    if abs(det) < 1e-6:  # Close to singular
        # Add small value to diagonal
        for i in range(3):
            matrix[i][i] += 1e-6
        det = matrix_determinant(matrix)

    a, b, c = matrix[0]
    d, e, f = matrix[1]
    g, h, i = matrix[2]

    # Calculate cofactor matrix
    cofactor = [
        [(e * i - f * h), -(d * i - f * g), (d * h - e * g)],
        [-(b * i - c * h), (a * i - c * g), -(a * h - b * g)],
        [(b * f - c * e), -(a * f - c * d), (a * e - b * d)],
    ]

    # Transpose and divide by determinant
    inverse = [[cofactor[j][i] / det for j in range(3)] for i in range(3)]
    return inverse


def matrix_add(A, B):
    """
    Add two matrices element-wise.
    """
    return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]


def matrix_scalar_multiply(matrix, scalar):
    """
    Multiply a matrix by a scalar.
    """
    return [
        [matrix[i][j] * scalar for j in range(len(matrix[0]))]
        for i in range(len(matrix))
    ]


def vector_subtract(v1, v2):
    """
    Subtract v2 from v1 element-wise.
    """
    return [v1[i] - v2[i] for i in range(len(v1))]


def matrix_vector_multiply(matrix, vector):
    """
    Multiply a matrix by a vector.
    """
    return [
        sum(matrix[i][j] * vector[j] for j in range(len(vector)))
        for i in range(len(matrix))
    ]


def vector_dot_product(v1, v2):
    """
    Compute the dot product of two vectors.
    """
    return sum(v1[i] * v2[i] for i in range(len(v1)))


def bhattacharyya_distance(mu_u, sigma_u, mu_i, sigma_i):
    """
    Compute the Bhattacharyya distance between two multivariate Gaussians.

    Parameters:
        mu_u (list): Mean vector of the unknown color
        sigma_u (list): Covariance matrix of the unknown color
        mu_i (list): Mean vector of the known color
        sigma_i (list): Covariance matrix of the known color

    Returns:
        float: Bhattacharyya distance
    """
    # Compute (sigma_i + sigma_u) / 2
    sigma = matrix_scalar_multiply(matrix_add(sigma_i, sigma_u), 0.5)
    mean_diff = vector_subtract(mu_u, mu_i)

    try:
        sigma_inv = matrix_inverse(sigma)
    except Exception:
        # Add small value to diagonal if singular
        for i in range(3):
            sigma[i][i] += 1e-6
        sigma_inv = matrix_inverse(sigma)

    # First term: (1/8) * mean_diff.T @ sigma_inv @ mean_diff
    temp = matrix_vector_multiply(sigma_inv, mean_diff)
    left_term = vector_dot_product(mean_diff, temp) / 8.0

    # Calculate determinants
    det_sigma = matrix_determinant(sigma)
    det_sigma_i = matrix_determinant(sigma_i)
    det_sigma_u = matrix_determinant(sigma_u)

    # Handle determinants close to zero
    if abs(det_sigma_u) < 1e-6 or abs(det_sigma_i) < 1e-6 or abs(det_sigma) < 1e-6:
        det_sigma_u = max(det_sigma_u, 1e-6)
        det_sigma_i = max(det_sigma_i, 1e-6)
        det_sigma = max(det_sigma, 1e-6)

    # Second term: 0.5 * log(det_sigma / sqrt(det_sigma_i * det_sigma_u))
    right_term = 0.5 * math.log(det_sigma / math.sqrt(det_sigma_i * det_sigma_u))

    return left_term + right_term


def match_unknown_color(filename):
    """
    Matches an unknown color against known colors using Bhattacharyya distance.

    Parameters:
        filename (str): CSV file containing RGB values of the unknown color.
            or
        filename (list): list of lists of rgb values

    Returns:
        str: The closest matching color.
    """
    mu_u, sigma_u = multivariate_gaussian(filename)

    bhat_distances = {}
    for color in COLOR_DATA.keys():
        mu_i, sigma_i = retreive_mult_gaussian(color)
        bhat_distances[color] = bhattacharyya_distance(mu_u, sigma_u, mu_i, sigma_i)

    return min(
        bhat_distances, key=bhat_distances.get
    )  # Return color with smallest distance


def write_unknown_color(color, nb_data_points):
    """
    Writes a sample of the given color's RGB data to a new file for testing purposes.
    """
    with open(COLOR_DATA_DIR + f"/{color}_data.csv", "r") as coloF:
        with open("../unknown_color.csv", "w") as uF:
            for i, line in enumerate(coloF):
                if i >= nb_data_points:
                    break
                uF.write(line)


def test_matching_color():
    """
    Tests the color matching system with different known colors.
    """
    for color in ["red", "orange", "white"]:
        write_unknown_color(color, 20)
        given_color = match_unknown_color("../unknown_color.csv")
        if given_color == color:
            print(f"{color} test Passed\n")
        else:
            print(f"{color} test Failed\n")


if __name__ == "__main__":
    test_matching_color()
</file>

<file path="src/mission_control.py">
"""
Mission control module for managing the robot's firefighting mission.
"""
import logging
import threading
import time
from enum import Enum
from src.constants import (
    HALLWAY_PATH, ENTRANCE, BURNING_ROOM_ENTRY, BURNING_ROOM_SWEEP, RETURN_PATH,
    NORTH, FIRE_STATION, EAST, SOUTH, WEST
)

logger = logging.getLogger("mission")

MISSION_RETURN_TRIGGER = 120  # Start return to base after 2 minutes
MISSION_MAX_TIME = 180


class MissionState(Enum):
    INIT = "init"
    HALLWAY = "hallway"
    ROOM_ENTRY = "room_entry"
    SWEEP = "sweep"
    RETURN = "return"
    DONE = "done"


class MissionControl:
    """Manages the overall mission execution and state."""

    def __init__(self, drive, sensors, navigation, extinguisher, siren):
        self.drive = drive
        self.sensors = sensors
        self.navigation = navigation
        self.extinguisher = extinguisher
        self.siren = siren
        self.mission_running = False
        self.mission_start_time = None
        self.fires_detected = 0
        self.return_triggered = False
        self.max_retries = 3

    def run_mission(self):
        self.mission_running = True
        self.mission_start_time = time.time()
        state = MissionState.HALLWAY
        self.start_timer_monitor()  # Sets return after 2min
        self.start_emergency_monitor()  # Checks for emergency button
        self.siren.start()

        while self.mission_running and state != MissionState.DONE:
            if self.return_triggered:  # (sets to true after 2Min)
                state = MissionState.RETURN

            if state == MissionState.HALLWAY:
                state = MissionState.ROOM_ENTRY if self.navigate_hallway() else MissionState.RETURN

            elif state == MissionState.ROOM_ENTRY:
                if self.enter_burning_room():
                    self.siren.stop()
                    state = MissionState.SWEEP
                else:
                    state = MissionState.RETURN

            elif state == MissionState.SWEEP:
                self.sweep_burning_room()
                state = MissionState.RETURN

            elif state == MissionState.RETURN:
                self.return_to_base()
                state = MissionState.DONE

        elapsed_time = time.time() - self.mission_start_time
        logger.info(f"Ended Mission attempt in {elapsed_time:.1f} seconds")
        self.stop_mission()

    def navigate_hallway(self):
        """Navigate through the hallway to the entrance."""
        logger.info("Starting hallway navigation")

        for i, (x, y) in enumerate(HALLWAY_PATH[1:], 1):  # Skip first position (start)
            if not self.check_mission_status():
                return False

            if not self.attempt_navigation(x, y, "hallway_navigation"):
                return False

        current_pos = self.navigation.position
        expected_pos = HALLWAY_PATH[-1]
        if abs(current_pos[0] - expected_pos[0]) > 0.5 or abs(current_pos[1] - expected_pos[1]) > 0.5:
            logger.warning(f"Position off: expected {expected_pos}, got {current_pos}")
            self.navigation.localize()
            # Post localization attempts to go to the entrance.
            if not self.attempt_navigation(expected_pos[0], expected_pos[1], "hallway_final"):
                return False

        self.drive.turn(NORTH)
        logger.info("Hallway navigation completed")

        return True

    def enter_burning_room(self):
        """Enter the burning room if at entrance and orange line detected."""
        # First try to find and align with the orange entrance line
        logger.info("Attempting to enter burning room")

        # First check if we're at the entrance position
        current_pos = self.drive.position
        entrance_pos = ENTRANCE

        if current_pos != entrance_pos:
            logger.warning(f"Not at entrance position: expected {entrance_pos}, got {current_pos}")
            # Try to navigate to entrance first
            if not self.navigation.navigate_to(entrance_pos[0], entrance_pos[1]):
                logger.error("Failed to reach entrance position")
                return False

        if not self.sensors.check_for_entrance()[0]:
            if not self.navigation.align_with_entrance():
                logger.error("Failed to align with entrance")
                return False

        # Enter room (move one block north)
        logger.info("Entering burning room")
        self.drive.turn(NORTH)
        self.drive.advance_blocks(1)
        self.navigation.update_particles_after_movement(0, 1)
        sensor_data = self.sensors.get_sensor_data()
        self.navigation.update_particle_weights(sensor_data)
        self.navigation.update_position_estimate()

        # TODO: High potential for failure due to bad color sensor (green yellow weakness)
        room_type = self.navigation.identify_room()
        logger.info(f"Room identified as: {room_type}")

        return room_type == "burning room"

    def sweep_burning_room(self):
        """Sweep room for fires with localization."""
        logger.info("Starting burning room sweep")
        for x, y in BURNING_ROOM_SWEEP:
            if not self.check_mission_status() or self.return_triggered:
                break
            if self.attempt_navigation(x, y, "sweep_navigation"):
                fire_found, sensor_side = self.navigation.find_fire()
                if fire_found:
                    self.fires_detected += 1
                    logger.info(f"Fire detected at {self.drive.position}")
                    self.drop_on_sensor(sensor_side)
                    if self.extinguisher.get_fires_extinguished() >= 2:
                        logger.info("All fires extinguished")
                        break

    def start_emergency_monitor(self):
        """Start monitoring for emergency stop signal."""
        def monitor():
            while self.mission_running:
                if self.sensors.is_emergency_pressed():
                    logger.warning("EMERGENCY STOP ACTIVATED")
                    self.stop_mission()
                    break
                time.sleep(0.1)

        thread = threading.Thread(
            target=monitor(), daemon=True
        )
        thread.start()
        logger.info("Emergency stop monitor started")

    def start_timer_monitor(self):
        """Monitors time and forces return at 2 minute mark"""
        def monitor():
            while self.mission_running and not self.return_triggered:
                elapsed_time = time.time() - self.mission_start_time
                if elapsed_time >= 120:  # 2 minutes
                    logger.info("2-minute mark reached. Triggering return.")
                    self.return_triggered = True
                    break
                time.sleep(1)

        thread = threading.Thread(target=monitor, daemon=True)
        logger.info("Time monitor started (triggers RTB)")
        thread.start()

    def _perform_additional_fire_scan(self):
        """
        Perform additional scanning for fires if not all were found in the initial sweep.
        Uses a systematic scanning pattern.
        """
        logger.info("Starting additional fire scan")

        # Move to center of room for a systematic scan
        center_x = sum(point[0] for point in BURNING_ROOM_SWEEP) // len(BURNING_ROOM_SWEEP)
        center_y = sum(point[1] for point in BURNING_ROOM_SWEEP) // len(BURNING_ROOM_SWEEP)

        self.navigation.navigate_to(center_x, center_y)

        # Perform a 360-degree scan
        for direction in [NORTH, EAST, SOUTH, WEST]:
            if not self.mission_running:
                return

            self.drive.turn(direction)
            time.sleep(0.5)  # Pause to stabilize

            # Check for fire
            fire_found, sensor_side = self.navigation.find_fire()

            if fire_found:
                logger.info(f"Fire detected during additional scan on {sensor_side} sensor")
                self.fires_detected += 1

                # Drop cube on the specific sensor
                if sensor_side == "left":
                    self.drop_on_sensor("LEFT")
                elif sensor_side == "right":
                    self.drop_on_sensor("RIGHT")
                else:
                    self.extinguisher.drop_cube()

                # If we've now found all fires, we can stop
                if self.extinguisher.get_fires_extinguished() >= 2:
                    logger.info("All fires extinguished during additional scan")
                    return

    def return_to_base(self):
        """Return to base with localization."""
        logger.info("Returning to base")
        if self.drive.position[1] >= 3:  # In burning room
            self.attempt_navigation(BURNING_ROOM_ENTRY[0], BURNING_ROOM_ENTRY[1], "return_navigation")
            self.attempt_navigation(ENTRANCE[0], ENTRANCE[1], "return_navigation")
        for x, y in RETURN_PATH:
            if not self.check_mission_status():
                break
            self.attempt_navigation(x, y, "return_navigation")
        if self.drive.position == (0, 0):
            logger.info("Returned to base (0,0)")
        else:
            logger.warning(f"Stopped at {self.drive.position}")

    def drop_on_sensor(self, sensor: str):
        """Drop cube more precisely on a specific sensor."""
        ROTATION_SECONDS = 0.9
        FORWARD_MOVE = 0.5
        if sensor == "RIGHT":
            self.drive.turn_slightly_right(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE + 0.1)
            self.extinguisher.drop_cube()
            self.drive.move_backward_slightly(FORWARD_MOVE)
            self.drive.turn_slightly_left(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE - 0.1)
        else:
            self.drive.turn_slightly_left(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE + 0.1)
            self.extinguisher.drop_cube()
            self.drive.move_backward_slightly(FORWARD_MOVE)
            self.drive.turn_slightly_right(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE - 0.1)

    def stop_mission(self):
        """Stop the mission and all activities."""
        logger.info("Stopping mission")
        self.mission_running = False
        self.drive.stop()
        self.siren.stop()

    def check_mission_status(self):
        """Check if mission should continue 3 min hard limit."""
        if not self.mission_running:
            return False
        elapsed_time = time.time() - self.mission_start_time
        if elapsed_time >= 180:  # 3-minute hard limit
            logger.warning("Max mission time (3 minutes) reached!")
            self.stop_mission()
            return False
        return True

    def attempt_navigation(self, x, y, operation_key):
        """Attempt navigation with retries and localization."""
        retries = 0
        while retries < self.max_retries:
            if self.navigation.navigate_to(x, y):
                return True
            retries += 1
            logger.warning(f"Navigation to ({x}, {y}) failed, retry {retries}/{self.max_retries}")
            self.navigation.localize()  # Relocalize on failure
            # Sync localization to drive
            if not self.check_mission_status():
                return False
        logger.error(f"Max retries exceeded for {operation_key}")
        return False
</file>

<file path="utils/brick.py">
"""
Module that handles all interaction with the BrickPi hardware, eg,
sensors and motors.

Authors: Ryan Au, Younes Boubekeur
"""

from __future__ import annotations

from typing import Literal, Type
import math
import atexit
import os
import signal
import time
import sys


def busy_sleep(seconds: float):
    """A different form of time.sleep, which uses a while loop that
    constantly checks the time, to see if the duration has elapsed."""
    start = time.time()
    while (time.time() - start) < seconds:
        time.sleep(0.005)


class IOError(OSError):
    pass


# Save process ID of this program so we can force stop it later if needed
os.system(f"echo {os.getpid()} > ~/brickpi3_pid")
BP = None
try:
    from brickpi3 import Enumeration, FirmwareVersionError, SensorError, BrickPi3
    import spidev

    BP = BrickPi3()  # The BrickPi3 instance
except (ModuleNotFoundError, OSError, TypeError) as err:
    print(
        "A BrickPi module is missing, or BrickPi is missing, intializing dummy BP",
        file=sys.stderr,
    )
    print(f"Warning: {err.__class__.__name__}({err})", file=sys.stderr)
    from .dummy import Enumeration, FirmwareVersionError, SensorError, BrickPi3

    BP = BrickPi3()  # The BrickPi3 instance

_OLD_BP = BP


def restore_default_brick(bp=None):
    global BP
    if bp is None:
        BP = _OLD_BP
    else:
        BP = bp


WAIT_READY_INTERVAL = 0.01
INF = float("inf")

PORTS: dict[str, int] = {
    "1": BrickPi3.PORT_1,
    "2": BrickPi3.PORT_2,
    "3": BrickPi3.PORT_3,
    "4": BrickPi3.PORT_4,
    "A": BrickPi3.PORT_A,
    "B": BrickPi3.PORT_B,
    "C": BrickPi3.PORT_C,
    "D": BrickPi3.PORT_D,
}


def exception_handler(exception=Exception):
    def exception_handler_factory(func):
        def wrapper(*args, **kwargs):
            try:
                func(*args, **kwargs)
            except exception as err:
                print("ERROR:", err)

        return wrapper

    return exception_handler_factory


class RevEnumeration:
    """
    Take in a type object (class), finds every full-Uppercase attribute
    (constants) and creates a Reverse Enumeration, where the constant value
    is the key, and the constant's name is the value.
    """

    def __init__(self, enum):  # or *names, with no .split()
        "enum can be any type, but preferably a brickpi3.Enumeration object."
        self.keys = []
        for attr, val in enum.__dict__.items():
            if attr.isupper():
                self[val] = attr
        self.keys.sort()

    def __getitem__(self, key):
        "Allow performing get actions such as SENSOR_CODES[0]."
        return self.__dict__[str(key)]  # SENSOR_CODES -> self.enum?

    def __setitem__(self, key, attr):
        setattr(self, str(key), attr)
        self.keys.append(str(key))

    def __repr__(self):
        return ", ".join([f"{key}={self[key]}" for key in self.keys])


SENSOR_STATE = Enumeration("""
        VALID_DATA,
        NOT_CONFIGURED,
        CONFIGURING,
        NO_DATA,
        I2C_ERROR,
        INCORRECT_SENSOR_PORT,
    """)
SENSOR_CODES = RevEnumeration(SENSOR_STATE)


class ColorMapping:
    """
    Class that maps a color to a numeric code used by the color sensor.
    """

    def __init__(self, name: str, code: int):
        self.name = name
        self.code = code


class ColorMappings:
    """
    Color mappings based on the colors that can be detected by the color sensor.
    """

    UNKNOWN = ColorMapping("Unknown", 0)
    BLACK = ColorMapping("Black", 1)
    BLUE = ColorMapping("Blue", 2)
    GREEN = ColorMapping("Green", 3)
    YELLOW = ColorMapping("Yellow", 4)
    RED = ColorMapping("Red", 5)
    WHITE = ColorMapping("White", 6)
    ORANGE = ColorMapping("Orange", 7)

    _all_mappings = [UNKNOWN, BLACK, BLUE, GREEN, YELLOW, RED, WHITE, ORANGE]


class Color:
    """
    Namespace for color names, to reference them easily.
    """

    UNKNOWN = "Unknown"
    BLACK = "Black"
    BLUE = "Blue"
    GREEN = "Green"
    YELLOW = "Yellow"
    RED = "Red"
    WHITE = "White"
    ORANGE = "Orange"


_color_names_by_code = {c.code: c.name for c in ColorMappings._all_mappings}


class Brick(BrickPi3):
    """
    Wrapper class for the BrickPi3 class. Comes with additional methods such get_sensor_status.
    """

    def __init__(self, bp=None):
        if bp is None:
            self.bp = BP
        else:
            self.bp = bp
        child = self.__dict__
        parent = self.bp.__dict__
        for key in parent.keys():
            setattr(self, str(key), child.get(key, parent.get(key)))

    def get_sensor_status(self, port: Literal[1, 2, 4, 8]):
        """
        Read a sensor status.

        Keyword arguments:
        port - The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.

        Return a code from 0 to 4 with the following meanings:

        0: VALID_DATA
        1: NOT_CONFIGURED
        2: CONFIGURING
        3: NO_DATA
        4: I2C_ERROR
        5: INCORRECT_SENSOR_PORT
        """
        if port == self.PORT_1:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_1
            port_index = 0
        elif port == self.PORT_2:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_2
            port_index = 1
        elif port == self.PORT_3:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_3
            port_index = 2
        elif port == self.PORT_4:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_4
            port_index = 3
        else:
            raise IOError(
                "get_sensor error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4."
            )

        if self.SensorType[port_index] == self.SENSOR_TYPE.CUSTOM:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif self.SensorType[port_index] == self.SENSOR_TYPE.I2C:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0]
            for b in range(self.I2CInBytes[port_index]):
                outArray.append(0)
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif (
            self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH
            or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_TOUCH
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_TOUCH
            or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_ULTRASONIC
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_REFLECTED
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_AMBIENT
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_LISTEN
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_PROXIMITY
        ):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index] or (
                    self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH
                    and (
                        reply[4] == self.SENSOR_TYPE.NXT_TOUCH
                        or reply[4] == self.SENSOR_TYPE.EV3_TOUCH
                    )
                ):
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_FULL:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif (
            self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_ON
            or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_OFF
            or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_RED
            or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_GREEN
            or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_BLUE
            or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_OFF
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_DPS
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_CM
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_INCHES
        ):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif (
            self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_RAW_REFLECTED
            or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS_DPS
        ):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR_COMPONENTS:
            outArray = [
                self.SPI_Address,
                message_type,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_SEEK:
            outArray = [
                self.SPI_Address,
                message_type,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        elif self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_REMOTE:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if reply[3] == 0xA5:
                if reply[4] == self.SensorType[port_index]:
                    return reply[5]
                else:
                    return SENSOR_STATE.INCORRECT_SENSOR_PORT
            else:
                raise IOError("get_sensor error: No SPI response")

        raise IOError("get_sensor error: Sensor not configured or not supported.")


class Sensor:
    """
    Template Sensor class. Must implement set_mode(mode) to function.
    """

    class Status:
        VALID_DATA = "VALID_DATA"
        NOT_CONFIGURED = "NOT_CONFIGURED"
        CONFIGURING = "CONFIGURING"
        NO_DATA = "NO_DATA"
        I2C_ERROR = "I2C_ERROR"
        INCORRECT_SENSOR_PORT = "INCORRECT_SENSOR_PORT"

    ALL_SENSORS = {key: None for key in "1 2 3 4".split(" ")}

    def __init__(self, port: Literal[1, 2, 3, 4], bp=None):
        "Initialize sensor with a given port (1, 2, 3, or 4)."
        self.brick = Brick(bp=bp)
        self.port = PORTS[str(port).upper()]
        Sensor.ALL_SENSORS[str(port)] = self

    def get_status(self):
        """
        Get the sensor status of this sensor.

        Return one of the following status messages:
        VALID_DATA
        NOT_CONFIGURED
        CONFIGURING
        NO_DATA
        I2C_ERROR
        """
        return SENSOR_CODES[self.brick.get_sensor_status(self.port)]

    def set_port(self, port: Literal[1, 2, 3, 4]):
        "Change sensor port number. Does not unassign previous port."
        try:
            self.port = PORTS[str(port).upper()]
            self.set_mode(self.mode)
        except SensorError as error:
            return error

    def get_value(self):
        "Get the raw sensor value. May return a float, int, list or None if error."
        try:
            return self.brick.get_sensor(self.port)
        except SensorError:
            return None

    def get_raw_value(self):
        "Get the raw sensor value. May return a float, int, list or None if error."
        return self.get_value()

    def wait_ready(self):
        "Wait (pause program) until the sensor is initialized."
        while self.get_status() != Sensor.Status.VALID_DATA:
            time.sleep(WAIT_READY_INTERVAL)


def wait_ready_sensors(debug=False):
    for port, sensor in Sensor.ALL_SENSORS.items():
        if sensor is not None:
            if debug:
                print(f"Initializing Port {port}:", type(sensor).__name__)
            sensor.wait_ready()
    if debug:
        print("All Sensors Initialized")


class TouchSensor(Sensor):
    """
    Basic touch sensor class. There is only one mode.
    Gives values 0 to 1, with 1 meaning the button is being pressed.
    """

    def __init__(self, port: Literal[1, 2, 3, 4], mode: str = "touch", bp=None):
        """
        Initialize touch sensor with a given port number.
        mode does not need to be set and actually does nothing here.
        """
        super(TouchSensor, self).__init__(port, bp)
        self.set_mode(mode.lower())

    def set_mode(self, mode: str = "touch"):
        """
        Touch sensor only has one mode, and does not require an input.
        This method is useless unless you wish to re-initialize the sensor.
        """
        try:
            self.brick.set_sensor_type(self.port, BrickPi3.SENSOR_TYPE.TOUCH)
            self.mode = mode.lower()
            return True
        except SensorError as error:
            return error

    def is_pressed(self) -> bool:
        "Return True if pressed, False otherwise."
        return self.get_value() == 1


class EV3UltrasonicSensor(Sensor):
    """
    EV3 Ultrasonic Sensor. Default mode returns distance in centimeters (cm).

    Values given by modes:
    cm - centimeter measure (0 to 255)
    in - inches measure
    listen - 0 or 1, 1 means another ultrasonic sensor is detected
    """

    class Mode:
        "Mode for the EV3 Ultrasonic Sensor."

        CM = "cm"
        IN = "in"
        LISTEN = "listen"

    def __init__(self, port: Literal[1, 2, 3, 4], mode="cm", bp=None):
        super(EV3UltrasonicSensor, self).__init__(port, bp)
        self.set_mode(mode)

    def set_mode(self, mode: str):
        """
        Set ultrasonic sensor mode. Return True if mode change successful.
        cm - centimeter measure (0 to 255)
        in - inches measure
        listen - 0 or 1, 1 means another ultrasonic sensor is detected
        """
        try:
            if mode.lower() == self.Mode.CM:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_ULTRASONIC_CM
                )
            elif mode.lower() == self.Mode.IN:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_ULTRASONIC_INCHES
                )
            elif mode.lower() == self.Mode.LISTEN:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_ULTRASONIC_LISTEN
                )
            else:
                return False
            self.mode = mode.lower()
            return True
        except SensorError as error:
            return error

    def get_cm(self):
        if self.mode != self.Mode.CM:
            self.set_mode(self.Mode.CM)
            self.wait_ready()
        return self.get_value()

    def get_inches(self):
        if self.mode != self.Mode.IN:
            self.set_mode(self.Mode.IN)
            self.wait_ready()
        return self.get_value()

    def detects_other_us_sensor(self):
        if self.mode != self.Mode.LISTEN:
            self.set_mode(self.Mode.LISTEN)
            self.wait_ready()
        return self.get_value() == 1


class EV3ColorSensor(Sensor):
    """
    EV3 Color Sensor. Default mode is "component".

    Values given by modes:
    component - give list of values [Red, Green, Blue, Unknown?]
    ambient - light off, detect any light
    red - red light on, detect red value only
    rawred - give list of values [Red, Unknown?]
    id - provide a single integer value based on the sensor's guess of detected color
    """

    class Mode:
        "Mode for the EV3 Color Sensor."

        COMPONENT = "component"
        AMBIENT = "ambient"
        RED = "red"
        RAW_RED = "rawred"
        ID = "id"

    def __init__(self, port, mode="component", bp=None):
        super(EV3ColorSensor, self).__init__(port, bp)
        self.set_mode(mode)

    def set_mode(self, mode: str):
        """
        Sets color sensor mode. Return True if mode change successful.

        component - give list of values [Red, Green, Blue, Unknown?]
        ambient - light off, detect any light
        red - red light on, detect red value only
        rawred - give list of values [Red, Unknown?]
        id - provide a single integer value based on the sensor's guess of detected color
        """
        try:
            if mode.lower() == self.Mode.COMPONENT:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_COLOR_COLOR_COMPONENTS
                )
            elif mode.lower() == self.Mode.AMBIENT:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_COLOR_AMBIENT
                )
            elif mode.lower() == self.Mode.RED:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_COLOR_REFLECTED
                )
            elif mode.lower() == self.Mode.RAW_RED:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_COLOR_RAW_REFLECTED
                )
            elif mode.lower() == self.Mode.ID:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_COLOR_COLOR
                )
            else:
                return False
            self.mode = mode.lower()
            return True
        except SensorError as error:
            return error

    def get_ambient(self) -> float:
        "Returns the ambient light detected by the sensor. Light will not turn on."
        if self.mode != self.Mode.AMBIENT:
            self.set_mode(self.Mode.AMBIENT)
            self.wait_ready()
        return self.get_value()

    def get_rgb(self) -> list[float]:
        "Return the RGB values from the sensor. This will switch the sensor to component mode."
        if self.mode != self.Mode.COMPONENT:
            self.set_mode(self.Mode.COMPONENT)
            self.wait_ready()
        val = self.get_value()
        return val[:-1] if val is not None else [None, None, None]

    def get_red(self) -> float:
        "Returns the red light detected by the sensor. Only red light turns on."
        if self.mode != self.Mode.RED:
            self.set_mode(self.Mode.RED)
            self.wait_ready()
        return self.get_value()


class EV3GyroSensor(Sensor):
    """
    EV3 Gyro sensor. Default mode is "both".

    Values given by modes:
    abs - Absolute degrees rotated since start
    dps - Degrees per second of rotation
    both - list of [abs, dps] values
    """

    class Mode:
        "Mode for the EV3 Gyro Sensor."

        ABS = "abs"
        DPS = "dps"
        BOTH = "both"

    def __init__(self, port: Literal[1, 2, 3, 4], mode="both", bp=None):
        super(EV3GyroSensor, self).__init__(port, bp)
        self.set_mode(mode)

    def set_mode(self, mode: str):
        """
        Change gyro sensor mode.

        abs - Absolute degrees rotated since start
        dps - Degrees per second of rotation
        both - list of [abs, dps] values
        """
        try:
            if mode.lower() == self.Mode.ABS:
                self.brick.set_sensor_type(self.port, BrickPi3.SENSOR_TYPE.EV3_GYRO_ABS)
            elif mode.lower() == self.Mode.DPS:
                self.brick.set_sensor_type(self.port, BrickPi3.SENSOR_TYPE.EV3_GYRO_DPS)
            elif mode.lower() == self.Mode.BOTH:
                self.brick.set_sensor_type(
                    self.port, BrickPi3.SENSOR_TYPE.EV3_GYRO_ABS_DPS
                )
            else:
                return False
            self.mode = mode.lower()
            return True
        except SensorError as error:
            return error

    def reset_measure(self):
        return self.set_mode(self.mode.lower())

    def get_abs_measure(self):
        if self.mode != self.Mode.ABS:
            self.set_mode(self.Mode.ABS)
            self.wait_ready()
        return self.get_value()

    def get_dps_measure(self):
        if self.mode != self.Mode.DPS:
            self.set_mode(self.Mode.DPS)
            self.wait_ready()
        return self.get_value()

    def get_both_measure(self):
        if self.mode != self.Mode.BOTH:
            self.set_mode(self.Mode.BOTH)
            self.wait_ready()
        return self.get_value()


class Motor:
    "Motor class for any motor."

    INF = INF
    MAX_SPEED = 1560  # positive or negative degree per second speed
    MAX_POWER = 100  # positive or negative percent power

    def __init__(self, port: Literal["A", "B", "C", "D"] | list[str], bp=None):
        """
        Initialize this Motor object with the ports "A", "B", "C", or "D".
        You may also provide a list of these ports such as ["A", "C"] to run
        both motors at the exact same time (exact combined behavior unknown).
        """
        self.brick = Brick(bp)
        self.set_port(port)

    def set_port(self, port):
        """
        Port can be "A", "B", "C", or "D".
        You may also provide a list of these ports such as ["A", "C"] to run
        both motors at the exact same time (exact combined behavior unknown).
        """
        if isinstance(port, list):
            self.port = sum([PORTS[i] for i in port])
        elif isinstance(port, int) or isinstance(port, str):
            self.port = PORTS[str(port).upper()]

    def set_power(self, power):
        """
        Commands the motor to rotate continuously. Will rotate at the given power percentage.
        (Constant-Type Motor Control)

        Percentage has no directly associated speed in (deg/sec). However, the maximum
        speed of the motor is "potentially" 1250 deg/sec. The actual speed of the motor
        may fluctuate based on the strength of the power source (battery) attached to
        the robot.

        SIDE EFFECTS:
        STOPS ALL (Position-Type Motor Control) methods.
        IT RESETS any limits defined by 'Motor.set_limits(power, dps)'
        SOLIDLY STOPS the motor if given 'Motor.set_power(0)'

        Keyword arguments:
        power - The power from -100 to 100, or -128 for float
        """
        self.brick.set_motor_power(self.port, power)

    def float_motor(self):
        """(Float the motor), which unlocks the motor, and allows outside forces to rotate it.

        NORMALLY, when powered, the motor will maintain its current position,
        and prevent outside forces from rotating it.

        This function (float_motor) commands the motor to allow outside forces to rotate it.
        The motor will still record speed and position, such that the corresponding functions
        still work: (get_speed) and (get_position).

        SIDE EFFECTS:
        It DOES NOT RESET any limits defined by (Motor.set_limits)
        The Motor will stop any current movements, then unlock
        """
        self.brick.set_motor_power(self.port, -128)

    def set_position(self, position):
        """
        Command the motor rotate a given number of degrees away from its origin 0.
        (Position-Type Motor Control)

        The origin is defined as either (the current position when the robot turns on)
        OR
        (the current position, when 'Motor.reset_encoder()' is called)

        BEHAVIOR:
        1. Reset Encoder
        2. Set Position to 60
        3. Motor rotates 60 degrees
        4. Set Position to 60
        5. Motor maintains its current position
        6. Reset Encoder
        7. Motor rotates 60 more degrees
            (because current position becomes 0. Motor tries to maintain last set position)

        SIDE EFFECTS:
        If you use Motor.set_position IMMEDIATELY AFTER Motor.set_power or Motor.set_dps,
            it will rotate at FULL POWER. This may crash the robot.
        """
        self.brick.set_motor_position(self.port, position)

    def set_position_relative(self, degrees):
        """
        Command the motor rotate a given number of degrees away from its current position.
        It does rotations relative to its current position (not based on the absolute origin).
        (Position-Type Motor Control)

        The origin is defined as either (the current position when the robot turns on)
        OR
        (the current position, when 'Motor.reset_encoder()' is called)

        BEHAVIOR:
        1. Reset Encoder
        2. Set Relative Position to 60
        3. Motor rotates 60 degrees
        4. Set Relative Position to 60
        5. Motor rotates another 60 degrees
        6. Reset Encoder
        7. Motor rotates 120 degrees
            because current position becomes 0.
            Motor tries to maintain last set position of 120 degrees (60 + 60).

        SIDE EFFECTS:
        If you use Motor.set_position IMMEDIATELY AFTER Motor.set_power or Motor.set_dps,
            it will rotate at FULL POWER. This may crash the robot.
        """
        self.brick.set_motor_position_relative(self.port, degrees)

    def set_position_kp(self, kp=25):
        """
        Set the motor target position KP constant.

        If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
        kd slows down the motor as it approaches the target, and helps to prevent overshoot.
        In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

        Keyword arguments:
        kp - The KP constant (default 25)
        """
        self.brick.set_motor_position_kp(self.port, kp)

    def set_position_kd(self, kd=70):
        """
        Set the motor target position KD constant.

        If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
        kd slows down the motor as it approaches the target, and helps to prevent overshoot.
        In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

        Keyword arguments:
        kd - The KD constant (default 70)
        """
        self.brick.set_motor_position_kd(self.port, kd)

    def set_dps(self, dps):
        """
        Commands the motor to rotate continuously. Will rotate at the given speed (deg/sec).
        (Constant-Type Motor Control)

        The maximum speed of the motor is "potentially" 1250 deg/sec.
        The actual speed of the motor may fluctuate based on the strength
        of the power source (battery) attached to the robot.

        SIDE EFFECTS:
        STOPS ALL (Position-Type Motor Control) methods.
        IT RESETS any limits defined by 'Motor.set_limits(power, dps)'
        SOLIDLY STOPS the motor if given 'Motor.set_dps(0)'

        Keyword arguments:
        dps - The target speed in degrees per second
        """
        self.brick.set_motor_dps(self.port, dps)
        self.set_limits(dps=dps)

    def set_limits(self, power=0, dps=0):
        """
        Set the motor speed limit. The speed is limited to whichever value is
        slowest, power or dps.
        (Position-Type Motor Control)

        It provides a maximum speed limit for both the Motor.set_position and
        Motor.set_position_relative
        Since the maximum potential speed of a motor is 1250 dps, then a power of 50%
        could potentially give a speed of 625 dps.


        Keyword arguments:
        power - The power limit in percent (0 to 100), with 0 being no limit (100)
        dps - The speed limit in degrees per second, with 0 being no limit
        """
        self.brick.set_motor_limits(self.port, power, dps)

    def get_status(self):
        """
        Read a motor status.

        Keyword arguments:
        port - The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.

        Returns a list:
            flags - 8-bits of bit-flags that indicate motor status:
                bit 0 - LOW_VOLTAGE_FLOAT - The motors are automatically disabled because the battery voltage is too low
                bit 1 - OVERLOADED - The motors aren't close to the target (applies to position control and dps speed control).
            power - the raw PWM power in percent (-100 to 100)
            encoder - The encoder position
            dps - The current speed in Degrees Per Second
        """
        try:
            return self.brick.get_motor_status(self.port)
        except IOError:
            return [None, None, None, None]

    def get_encoder(self):
        """
        Read a motor encoder in degrees. The current position of the motor.
        The encoder will read degrees cumulatively. Every full rotation counts as 360.
        The range for encoder values it can maintain is -2147483648 to 2147483647

        Keyword arguments:
        Returns the encoder position in degrees
        """
        return self.brick.get_motor_encoder(self.port)

    def get_position(self):
        """
        Read a motor encoder in degrees. The current position of the motor.
        The encoder will read degrees cumulatively. Every full rotation counts as 360.
        The range for encoder values it can maintain is -2147483648 to 2147483647

        Keyword arguments:
        Returns the encoder position in degrees
        """
        return self.get_encoder()

    def get_power(self):
        """
        Read motor status and returns power percent (-100 to 100)

        Returns:
            None if error encountered
            Numeric Value -100 to 100 of raw power percent
        """
        return self.get_status()[1]

    def get_speed(self):
        """
        Read motor status and returns speed in degrees per second

        Returns:
            None if error encountered
            Numeric Value, negative or positive, in degrees per second
        """
        return self.get_status()[3]

    def is_moving(self):
        try:
            return (not math.isclose(self.get_power(), 0)) and (
                not math.isclose(self.get_speed(), 0)
            )
        except TypeError:
            return None

    def get_dps(self):
        return self.get_speed()

    def offset_encoder(self, position):
        """
        Offset a motor encoder.
        The range for encoder values it can maintain is -2147483648 to 2147483647
        It will overflow from 2147483647 to -2147483648

        BEHAVIOR:
        If the current position is 350, and we run Motor.offset_encoder(350),
        then the current position becomes 0.

        Keyword arguments:
        offset - The encoder offset

        You can zero the encoder by offsetting it by the current position
        """
        self.brick.offset_motor_encoder(self.port, position)

    def reset_encoder(self):
        """
        Reset motor encoder(s) to 0.

        Keyword arguments:
        """
        self.brick.reset_motor_encoder(self.port)

    def reset_position(self):
        """
        Reset motor encoder(s) to 0.
        """
        return self.reset_encoder()

    @staticmethod
    def create_motors(motor_ports: list[Literal["A", "B", "C", "D"]] | str):
        motor_ports = map(str.upper, list(motor_ports))
        result = []
        for port in motor_ports:
            if port in ["A", "B", "C", "D"]:
                result.append(Motor(port))
        return tuple(result)

    def wait_is_moving(self, sleep_interval: float = None):
        if sleep_interval is None:
            sleep_interval = WAIT_READY_INTERVAL
        while not self.is_moving():
            time.sleep(sleep_interval)

    def wait_is_stopped(self, sleep_interval: float = None):
        if sleep_interval is None:
            sleep_interval = WAIT_READY_INTERVAL
        while self.is_moving():
            time.sleep(sleep_interval)


def create_motors(motor_ports: list[Literal["A", "B", "C", "D"]] | str):
    return Motor.create_motors(motor_ports)


def configure_ports(
    *,
    PORT_1: Type[Sensor] = None,
    PORT_2: Type[Sensor] = None,
    PORT_3: Type[Sensor] = None,
    PORT_4: Type[Sensor] = None,
    PORT_A: Type[Motor] = None,
    PORT_B: Type[Motor] = None,
    PORT_C: Type[Motor] = None,
    PORT_D: Type[Motor] = None,
    wait: bool = True,
    print_status: bool = True,
) -> Sensor | Motor | list[Sensor | Motor]:
    """
    Configure the ports to use the specified sensor or motor and return objects for each item,
    ordered by sensor ports followed by motor ports.

    When wait is True (the default), the function will wait for the sensors to be ready before returning.
    When print_status is True (the default), the function will print two messages, the first to let the user
    know to wait until the ports are configured, and the second to indicate the port configuration is complete.

    Example:

    TOUCH_SENSOR, COLOR_SENSOR, MOTOR = configure_ports(PORT_1=TouchSensor, PORT_3=EV3ColorSensor, PORT_A=Motor)
    """
    sensor_ports = [PORT_1, PORT_2, PORT_3, PORT_4]
    motor_ports = [PORT_A, PORT_B, PORT_C, PORT_D]
    is_single_device = False
    if (sensor_ports + motor_ports).count(None) == 7:  # if only one device configured
        is_single_device = True
    if print_status:
        print(f"Configuring port{'' if is_single_device else 's'}, please wait...")
    sensors: list[Sensor] = []
    motors: list[Motor] = []
    for n, sensor_type in enumerate(sensor_ports, 1):
        if sensor_type:
            sensor = sensor_type(n)
            if wait:
                if isinstance(sensor, (EV3UltrasonicSensor, EV3ColorSensor)):
                    sensor.wait_ready()
            if is_single_device:
                return sensor
            sensors.append(sensor)
    for letter, motor_type in zip("ABCD", motor_ports):
        if motor_type:
            if is_single_device:
                return motor_type(letter)
            motors.append(motor_type(letter))
    if print_status:
        print("Port configuration complete!")
    return sensors + motors


def reset_brick(*args):
    "Reset BrickPi devices when program exits ('at exit')."
    BP.reset_all()


# Reset brick when the program exits
try:
    atexit.register(reset_brick)
except ValueError as err:
    print(err, "Must import brick in main thread", file=sys.stderr)
</file>

<file path="utils/dummy.py">
from math import inf
import threading
from typing import Literal
import time


class Enumeration(object):
    def __init__(self, names):  # or *names, with no .split()
        number = 0
        for line, name in enumerate(names.split('\n')):
            if name.find(",") >= 0:
                # strip out the spaces
                while(name.find(" ") != -1):
                    name = name[:name.find(" ")] + name[(name.find(" ") + 1):]

                # strip out the commas
                while(name.find(",") != -1):
                    name = name[:name.find(",")] + name[(name.find(",") + 1):]

                # if the value was specified
                if(name.find("=") != -1):
                    number = int(float(name[(name.find("=") + 1):]))
                    name = name[:name.find("=")]

                # optionally print to confirm that it's working correctly
                # print "%40s has a value of %d" % (name, number)

                setattr(self, name, number)
                number = number + 1


class FirmwareVersionError(Exception):
    """Exception raised if the BrickPi3 firmware needs to be updated"""


class SensorError(Exception):
    """Exception raised if a sensor is not yet configured when trying to read it with get_sensor"""


class _FakeMotor:
    MAX_SPEED = 1050
    MAX_POS = 65536
    THREAD_INTERVAL = 0.2

    def __init__(self):
        self.event = threading.Event()
        self.thread = threading.Thread(target=self._listener, daemon=True)

        self.position_goal = None
        self.state = 0

        self.position = 0
        self.speed = 0  # Maximum is 1050dps
        self.power = 0  # Maximum is 1050dps

        self.set_limits()

    def start(self):
        self.event.set()
        self.thread.start()

    @staticmethod
    def limit(val, lower, upper):
        return min(max(val, lower), upper)

    @staticmethod
    def abs_limit(val, limit):
        limit = abs(limit)
        return _FakeMotor.limit(val, -limit, limit)

    def _listener(self, *args):
        while self.event.is_set():
            if self.position_goal is not None:
                if self.state == 0:
                    self.state = -1 if self.position_goal < self.position else 1
                best_speed = self.state * min(self.speed_limit,
                                         self.power_limit/100*self.MAX_SPEED)
                self.speed = best_speed
                self.power = best_speed * 100 / self.MAX_SPEED

                if (self.state == -1 and self.position <= self.position_goal) or (self.state == 1 and self.position >= self.position_goal):
                    self.set_position(self.position_goal)
                    self.position_goal = None
                    self.state = 0
                    self.speed = 0
                    self.power = 0
            else:
                self.state = 0
            delta_pos = self.speed * self.THREAD_INTERVAL
            self.set_position(self.position + delta_pos)
            time.sleep(self.THREAD_INTERVAL)

    def go_position(self, goal):
        self.stop()
        self.position_goal = self.abs_limit(goal, self.MAX_POS)

    def stop(self):
        self.speed = 0
        self.power = 0
        self.state = 0
        self.position_goal = None

    def power_to_speed(self):
        self.speed = self.power / 100 * self.MAX_SPEED

    def speed_to_power(self):
        self.power = self.speed / self.MAX_SPEED * 100

    def set_limits(self, power=0, speed=0):
        power = abs(power)
        speed = abs(speed)
        if power == 0:
            self.power_limit = 100
        else:
            self.power_limit = self.limit(power, 0, 100)
        if speed == 0:
            self.speed_limit = self.MAX_SPEED
        else:
            self.speed_limit = self.limit(speed, 0, self.MAX_SPEED)

    def set_power(self, power):
        self.stop()
        self.power = power
        self.power_to_speed()

    def set_speed(self, speed):
        self.stop()
        self.speed = speed
        self.speed_to_power()

    def set_position(self, pos):
        if pos is None:
            self.position = 0
        self.position = round((self.abs_limit(pos, self.MAX_POS) +
                               self.MAX_POS) % (131072+1) - self.MAX_POS, 1)

    def shutdown(self):
        self.event.clear()

    def __del__(self):
        self.shutdown()


class BrickPi3():
    PORT_1 = 0x01
    PORT_2 = 0x02
    PORT_3 = 0x04
    PORT_4 = 0x08

    PORT_A = 0x01
    PORT_B = 0x02
    PORT_C = 0x04
    PORT_D = 0x08

    MOTOR_FLOAT = -128

    SensorType = [0, 0, 0, 0]
    I2CInBytes = [0, 0, 0, 0]

    I2C_LENGTH_LIMIT = 16

    BPSPI_MESSAGE_TYPE = Enumeration("""
        NONE,

        GET_MANUFACTURER,
        GET_NAME,
        GET_HARDWARE_VERSION,
        GET_FIRMWARE_VERSION,
        GET_ID,
        SET_LED,
        GET_VOLTAGE_3V3,
        GET_VOLTAGE_5V,
        GET_VOLTAGE_9V,
        GET_VOLTAGE_VCC,
        SET_ADDRESS,

        SET_SENSOR_TYPE,

        GET_SENSOR_1,
        GET_SENSOR_2,
        GET_SENSOR_3,
        GET_SENSOR_4,

        I2C_TRANSACT_1,
        I2C_TRANSACT_2,
        I2C_TRANSACT_3,
        I2C_TRANSACT_4,

        SET_MOTOR_POWER,

        SET_MOTOR_POSITION,

        SET_MOTOR_POSITION_KP,

        SET_MOTOR_POSITION_KD,

        SET_MOTOR_DPS,

        SET_MOTOR_DPS_KP,

        SET_MOTOR_DPS_KD,

        SET_MOTOR_LIMITS,

        OFFSET_MOTOR_ENCODER,

        GET_MOTOR_A_ENCODER,
        GET_MOTOR_B_ENCODER,
        GET_MOTOR_C_ENCODER,
        GET_MOTOR_D_ENCODER,

        GET_MOTOR_A_STATUS,
        GET_MOTOR_B_STATUS,
        GET_MOTOR_C_STATUS,
        GET_MOTOR_D_STATUS,
    """)

    SENSOR_TYPE = Enumeration("""
        NONE = 1,
        I2C,
        CUSTOM,

        TOUCH,
        NXT_TOUCH,
        EV3_TOUCH,

        NXT_LIGHT_ON,
        NXT_LIGHT_OFF,

        NXT_COLOR_RED,
        NXT_COLOR_GREEN,
        NXT_COLOR_BLUE,
        NXT_COLOR_FULL,
        NXT_COLOR_OFF,

        NXT_ULTRASONIC,

        EV3_GYRO_ABS,
        EV3_GYRO_DPS,
        EV3_GYRO_ABS_DPS,

        EV3_COLOR_REFLECTED,
        EV3_COLOR_AMBIENT,
        EV3_COLOR_COLOR,
        EV3_COLOR_RAW_REFLECTED,
        EV3_COLOR_COLOR_COMPONENTS,

        EV3_ULTRASONIC_CM,
        EV3_ULTRASONIC_INCHES,
        EV3_ULTRASONIC_LISTEN,

        EV3_INFRARED_PROXIMITY,
        EV3_INFRARED_SEEK,
        EV3_INFRARED_REMOTE,
    """)

    SENSOR_STATE = Enumeration("""
        VALID_DATA,
        NOT_CONFIGURED,
        CONFIGURING,
        NO_DATA,
        I2C_ERROR,
    """)

    SENSOR_CUSTOM = Enumeration("""
        PIN1_9V,
        PIN5_OUT,
        PIN5_STATE,
        PIN6_OUT,
        PIN6_STATE,
        PIN1_ADC,
        PIN6_ADC,
    """)
    """
    Flags for use with SENSOR_TYPE.CUSTOM

    PIN1_9V
        Enable 9V out on pin 1 (for LEGO NXT Ultrasonic sensor).

    PIN5_OUT
        Set pin 5 state to output. Pin 5 will be set to input if this flag is not set.

    PIN5_STATE
        If PIN5_OUT is set, this will set the state to output high, otherwise the state will
        be output low. If PIN5_OUT is not set, this flag has no effect.

    PIN6_OUT
        Set pin 6 state to output. Pin 6 will be set to input if this flag is not set.

    PIN6_STATE
        If PIN6_OUT is set, this will set the state to output high, otherwise the state will
        be output low. If PIN6_OUT is not set, this flag has no effect.

    PIN1_ADC
        Enable the analog/digital converter on pin 1 (e.g. for NXT analog sensors).

    PIN6_ADC
        Enable the analog/digital converter on pin 6.
    """

    SENSOR_CUSTOM.PIN1_9V = 0x0002
    SENSOR_CUSTOM.PIN5_OUT = 0x0010
    SENSOR_CUSTOM.PIN5_STATE = 0x0020
    SENSOR_CUSTOM.PIN6_OUT = 0x0100
    SENSOR_CUSTOM.PIN6_STATE = 0x0200
    SENSOR_CUSTOM.PIN1_ADC = 0x1000
    SENSOR_CUSTOM.PIN6_ADC = 0x4000

    SENSOR_I2C_SETTINGS = Enumeration("""
        MID_CLOCK,
        PIN1_9V,
        SAME,
        ALLOW_STRETCH_ACK,
        ALLOW_STRETCH_ANY,
    """)

    # Send the clock pulse between reading and writing. Required by the NXT US sensor.
    SENSOR_I2C_SETTINGS.MID_CLOCK = 0x01
    SENSOR_I2C_SETTINGS.PIN1_9V = 0x02  # 9v pullup on pin 1
    # Keep performing the same transaction e.g. keep polling a sensor
    SENSOR_I2C_SETTINGS.SAME = 0x04

    MOTOR_STATUS_FLAG = Enumeration("""
        LOW_VOLTAGE_FLOAT,
        OVERLOADED,
    """)

    # If the motors are floating due to low battery voltage
    MOTOR_STATUS_FLAG.LOW_VOLTAGE_FLOAT = 0x01
    # If the motors aren't close to the target (applies to position control and dps speed control).
    MOTOR_STATUS_FLAG.OVERLOADED = 0x02

    #SUCCESS = 0
    #SPI_ERROR = 1
    #SENSOR_ERROR = 2
    #SENSOR_TYPE_ERROR = 3

    @classmethod
    def _convert_port(cls, port):
        if port == cls.PORT_1:
            message_type = cls.BPSPI_MESSAGE_TYPE.GET_SENSOR_1
            port_index = 0
        elif port == cls.PORT_2:
            message_type = cls.BPSPI_MESSAGE_TYPE.GET_SENSOR_2
            port_index = 1
        elif port == cls.PORT_3:
            message_type = cls.BPSPI_MESSAGE_TYPE.GET_SENSOR_3
            port_index = 2
        elif port == cls.PORT_4:
            message_type = cls.BPSPI_MESSAGE_TYPE.GET_SENSOR_4
            port_index = 3
        else:
            raise IOError(
                "get_sensor error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4.")
        return (port_index, message_type)

    def __init__(self, addr=1, detect=True):
        self.SPI_Address = 1
        self.SensorType = [None for i in range(4)]
        self.Motors = [_FakeMotor() for i in range(4)]
        self.SPI_Messages = {self._convert_port(2**i)[1]: i for i in range(4)}
        for mot in self.Motors:
            mot.start()

        self._internal_data = {
            BrickPi3.SENSOR_TYPE.TOUCH: 0,
            BrickPi3.SENSOR_TYPE.EV3_ULTRASONIC_CM: 255.0,
            BrickPi3.SENSOR_TYPE.EV3_ULTRASONIC_INCHES: 100.0,
            BrickPi3.SENSOR_TYPE.EV3_ULTRASONIC_LISTEN: 0,
            BrickPi3.SENSOR_TYPE.EV3_COLOR_COLOR_COMPONENTS: (0, 0, 0, 0),
            BrickPi3.SENSOR_TYPE.EV3_COLOR_AMBIENT: (0, 0, 0, 0),
            BrickPi3.SENSOR_TYPE.EV3_COLOR_REFLECTED: 0,
            BrickPi3.SENSOR_TYPE.EV3_COLOR_RAW_REFLECTED: 0,
            BrickPi3.SENSOR_TYPE.EV3_COLOR_COLOR: 0,
            BrickPi3.SENSOR_TYPE.EV3_GYRO_ABS: 0,
            BrickPi3.SENSOR_TYPE.EV3_GYRO_DPS: 0,
            BrickPi3.SENSOR_TYPE.EV3_GYRO_ABS_DPS: (0, 0)
        }

    def __del__(self):
        if hasattr(self, "Motors"):
            try:
                for mot in self.Motors:
                    mot.shutdown()
            except TypeError:
                pass

    def spi_transfer_array(self, data_out):
        """Used by Brick.get_sensor_status"""
        """
        [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
        => [0,0,0,0xA5,self.SensorType[i],status]

        [self.SPI_Address, message_type, 0, 0, 0, 0]
        => [0,0,0,0xA5,self.SensorType[i],status]

        [self.SPI_Address, message_type, 0, 0, 0, 0, 0]
        => [0,0,0,0xA5,self.SensorType[i],status]

        [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        => [0,0,0,0xA5,self.SensorType[i],status]
        """
        SENSOR_STATUS = 0  # Valid Data
        BAD_REPLY = [0, 0, 0, 0, 0, 0]

        data = list(data_out)
        if len(data) < 2:
            return BAD_REPLY

        i = self.SPI_Messages.get(data[1], -1)
        GOOD_REPLY = [0, 0, 0, 0xA5, self.SensorType[i], SENSOR_STATUS]

        return GOOD_REPLY

    def spi_write_8(self, MessageType, Value):
        pass

    def spi_read_16(self, MessageType):
        pass

    def spi_write_16(self, MessageType, Value):
        pass

    def spi_write_24(self, MessageType, Value):
        pass

    def spi_read_32(self, MessageType):
        pass

    def spi_write_32(self, MessageType, Value):
        pass

    def get_manufacturer(self):
        pass

    def get_board(self):
        pass

    def get_version_hardware(self):
        pass

    def get_version_firmware(self):
        pass

    def get_id(self):
        pass

    def set_led(self, value):
        pass

    def get_voltage_3v3(self):
        pass

    def get_voltage_5v(self):
        pass

    def get_voltage_9v(self):
        pass

    def get_voltage_battery(self):
        pass

    def set_sensor_type(self, port, type, params=0):
        i, _ = self._convert_port(port)
        self.SensorType[i] = type

    def transact_i2c(self, port, Address, OutArray, InBytes):
        pass

    def set_sensor(self, port, value):
        """A special method only available to dummy.BrickPi3.
        Used to change the internal value of the fake sensors."""
        i, _ = self._convert_port(port)
        sensorType = self.SensorType[i]
        self._internal_data[sensorType] = value

    def get_sensor(self, port):
        i, _ = self._convert_port(port)
        sensorType = self.SensorType[i]

        return self._internal_data[sensorType]

    def set_motor_power(self, port, power):
        i, _ = self._convert_port(port)
        self.Motors[i].set_power(power)

    def set_motor_position(self, port, position):
        i, _ = self._convert_port(port)
        self.Motors[i].go_position(position)

    def set_motor_position_relative(self, port, degrees):
        pos = self.get_motor_encoder(port)
        self.set_motor_position(port, pos + degrees)

    def set_motor_position_kp(self, port, kp=25):
        pass

    def set_motor_position_kd(self, port, kd=70):
        pass

    def set_motor_dps(self, port, dps):
        i, _ = self._convert_port(port)
        self.Motors[i].set_speed(dps)

    def set_motor_limits(self, port, power=0, dps=0):
        i, _ = self._convert_port(port)
        self.Motors[i].set_limits(power, dps)

    def get_motor_status(self, port):
        i, _ = self._convert_port(port)
        return [0, self.Motors[i].power, self.Motors[i].position, self.Motors[i].speed]

    def get_motor_encoder(self, port):
        i, _ = self._convert_port(port)
        return self.Motors[i].position

    def offset_motor_encoder(self, port, position):
        i, _ = self._convert_port(port)
        self.Motors[i].set_position(position)

    def reset_motor_encoder(self, port):
        i, _ = self._convert_port(port)
        self.Motors[i].set_position(0)

    def reset_all(self):
        pass


class Brick(BrickPi3):
    """
    Wrapper class for the BrickPi3 class. Comes with additional methods such get_sensor_status.
    """

    def __init__(self):
        pass

    def get_sensor_status(self, port: Literal[1, 2, 4, 8]):
        if port not in self.SensorType:
            return 5  # INCORRECT_SENSOR_PORT
        if self.SensorType[port] is None:
            return 1  # NOT_CONFIGURED
        return 0  # VALID_DATA
</file>

<file path="utils/filters.py">
"""
Module for list-like filters that generate statistics based on a source list. 
Changes to the source list result in changes in the filters' results.

Author: Ryan Au
"""

import math
import time
from collections import UserList, deque
from statistics import mean, median
import threading


def range_limit(value: float, lower: float, upper: float) -> float:
    """Prevents the value from going beyond the upper or lower values.

    Example:
    range_limit(40,30,50)->40 (within bounds)
    range_limit(60,30,50)->50 (upper limit)
    range_limit(20,30,50)->30 (lower limit)

    >>> range_limit(40,30,50)
    40
    >>> range_limit(60,30,50)
    50
    >>> range_limit(20,30,50)
    30
    """
    return min(max(value, lower), upper)


def _wrap_index(i, l):
    """Changes an index from negative to the wrapped index based on length l.

    >>> _wrap_index(10, 5)
    10
    >>> _wrap_index(-10, 5)
    -5
    >>> _wrap_index(-4, 5)
    1
    """
    if i < 0:
        return l + i
    else:
        return i


class AtomicActor:
    def __init__(self):
        self.__atomic_lock__ = threading.RLock()

    def _atomic(func):
        def inner(*args, **kwargs):
            if len(args) == 0 or not isinstance(args[0], AtomicActor):
                raise RuntimeError(
                    "atomic decorator must be applied to a subclass of itself")
            self = args[0]
            with self.__atomic_lock__:
                return func(*args, **kwargs)
        return inner


class CircularList(AtomicActor):
    class Empty:
        def __eq__(self, __o: object) -> bool:
            return isinstance(__o, CircularList.Empty)

        def __repr__(self):
            return "Empty"

        def __bool__(self):
            return False

    def __init__(self, size: int):
        """Initializes the CircularList with a given size

        >>> c = CircularList(4)
        >>> len(c.data)
        4
        >>> c = CircularList(1)
        >>> len(c.data)
        1
        >>> c = CircularList(0) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: size must be positive non-zero value
        """
        super(CircularList, self).__init__()
        if type(size) != int:
            raise ValueError("size must be of type int")
        if size <= 0:
            raise ValueError("size must be positive non-zero value")
        self.size = size
        self.head = 0
        self.tail = None
        self.data = [CircularList.Empty() for i in range(size)]

    def __repr__(self):
        """String representation of this CircularList"""
        return repr(self.to_list())

    @AtomicActor._atomic
    def update(self, iterable):
        """Appends each element of the iterable to this list.
        The normal CircularList.append rules apply, and will overwrite
        the oldest added element always.

        >>> c = CircularList(3)
        >>> c.update([1,2,3,4,5])
        >>> c
        [3, 4, 5]
        >>> c.update([6,7,8,9])
        >>> c
        [7, 8, 9]
        >>> c.update([10, 11])
        >>> c
        [9, 10, 11]
        """
        for i in iterable:
            self.append(i)

    @AtomicActor._atomic
    def to_list(self):
        """
        Returns a List form of this CircularList.

        >>> c = CircularList(4)
        >>> c.to_list()
        []
        >>> c.append(1)
        Empty
        >>> c.to_list()
        [1]
        >>> c.update([2, 3, 4, 5])
        >>> c.to_list()
        [2, 3, 4, 5]
        >>> c.data
        [5, 2, 3, 4]
        """
        if self.tail is None:
            return list()
        if self.head <= self.tail:
            return self.data[self.head:self.tail+1]
        if self.tail < self.head:
            return [self.data[i] for i in self._slice(self.head, self.tail)]

    @AtomicActor._atomic
    def append(self, element):
        """
        Append an item to this list. Returns element if overriden,
        CircularList.Empty object if there was no element overriden.
        The first element is removed, if list would exceed its size.

        >>> c = CircularList(2)
        >>> c.append(1)
        Empty
        >>> c.append(2)
        Empty
        >>> c.append(3)
        1
        >>> c
        [2, 3]
        >>> c = CircularList(1)
        >>> c.append(1)
        Empty
        >>> c.append(2)
        1
        >>> c.append(3)
        2
        >>> c
        [3]
        >>> c.pophead()
        3
        >>> c.append(4)
        Empty
        >>> c
        [4]
        """

        if isinstance(element, CircularList.Empty):
            raise ValueError(
                "list element cannot be of the CircularList.Empty class")

        if self.tail is None:
            self.tail = self.head
        else:
            # Increment tail from current last element, to next element
            self.tail = (self.tail + 1) % self.size  # 0 to size-1
            if self.tail == self.head:
                self.head = (self.head + 1) % self.size

        last_item = self.data[self.tail]
        self.data[self.tail] = element
        return last_item

    @AtomicActor._atomic
    def pop(self):
        """Remove last added item and return it.

        >>> c = CircularList(2)
        >>> c.update([1, 2, 3])
        >>> c.pop()
        3
        >>> c.pop()
        2
        >>> c.append(4)
        Empty
        """
        if self.tail is None:
            raise RuntimeError("There are no items in this list")

        item = self.data[self.tail]
        self.data[self.tail] = CircularList.Empty()

        if self.head == self.tail:
            self.tail = None
        else:
            self.tail = (self.tail - 1) % self.size

        return item

    def poptail(self):
        """Remove last added item and return it."""
        return self.pop()

    @AtomicActor._atomic
    def pophead(self):
        """Remove first added item and return it."""
        if self.tail is None:
            raise RuntimeError("There are no items in this list")

        item = self.data[self.head]
        self.data[self.head] = CircularList.Empty()

        if self.head == self.tail:
            self.tail = None
        else:
            self.head = (self.head + 1) % self.size

        return item

    def _convert_index(self, index):
        """Converts any given index, into the corresponding circular index.
        Includes values 0 to size-1.

        Internally, it is only based self.head and self.size
        It ignores the current value of self.tail

        >>> c = CircularList(3)
        >>> c._convert_index(1)
        1
        >>> c.update([1, 2, 3, 4])
        >>> c._convert_index(1)
        2
        >>> c.update([5])
        >>> c._convert_index(1)
        0

        """
        index = index % self.size
        index = (self.head + index) % self.size
        return index

    def _slice(self, start, stop, step=1):
        """Slice for this CircularList, but STOP is inclusive

        Internally, only based on self.size

        >>> c = CircularList(5)
        >>> list(c._slice(0, 2))
        [0, 1, 2]
        >>> list(c._slice(0, 0))
        [0]
        >>> list(c._slice(2, 0))
        [2, 3, 4, 0]
        >>> list(c._slice(2, 1))
        [2, 3, 4, 0, 1]
        >>> list(c._slice(4, 1))
        [4, 0, 1]
        """
        start = start % self.size
        stop = stop % self.size
        if stop >= start:
            for i in range(start, stop+1, step):
                yield i
        elif start > stop:
            n = (self.size - start) + (stop+1)
            for i in range(0, n, step):
                yield (i+start) % self.size

    def _index_within(self, i):
        """Returns True if i is a valid element within the CircularList. False if not present."""
        if self.tail is None:
            return False
        elif self.tail >= self.head:
            return i <= self.tail and i >= self.head
        elif self.head > self.tail:
            return (i >= self.head and i < self.size) or (i >= 0 and i <= self.tail)

    @AtomicActor._atomic
    def __len__(self):
        """Get the length of the added elements

        >>> c = CircularList(5)
        >>> len(c)
        0
        >>> c.update([1,2,3])
        >>> len(c)
        3
        >>> c.update([4,5,6,7])
        >>> len(c)
        5
        >>> c.pophead()
        3
        >>> c.pophead()
        4
        >>> len(c)
        3
        """
        if self.tail is None:
            return 0
        elif self.head <= self.tail:
            return self.tail - self.head + 1
        elif self.head > self.tail:
            return self.size - self.head + (self.tail + 1)

    @AtomicActor._atomic
    def __getitem__(self, i: slice | int):
        """Gets an item from the list. 

        Raises IndexError if index is out of bounds or the list is empty

        >>> c = CircularList(5)
        >>> c.update([1])
        >>> c.update([2, 3, 4, 5, 6])
        >>> c[1:4]
        [3, 4, 5]
        >>> c.update([7, 8, 9, 10])
        >>> c[1:4]
        [7, 8, 9]
        >>> c.update([11, 12, 13])
        >>> c[1:4]
        [10, 11, 12]
        >>> c[2:0]
        []
        """
        if type(i) == int:
            if i >= self.__len__():
                raise IndexError("Index out of bounds")
            i = self._convert_index(i)
            item = self.data[i]
            if isinstance(item, CircularList.Empty):
                raise IndexError("Index is out of bounds")
            return item
        if type(i) == slice:
            start = 0 if i.start is None else i.start
            # Becomes the last index we do want to get. Might match start
            stop = self.size-1 if i.stop is None else i.stop-1

            if start > stop:
                return []

            n = self.__len__()
            start = range_limit(start % self.size, 0, n)
            stop = range_limit(stop % self.size, 0, n)

            start = self._convert_index(start)
            # inclusive stop, the index of the last element to get
            stop = self._convert_index(stop)
            step = 1 if i.step is None else i.step

            return [self.data[i] for i in self._slice(start, stop, step)]

    @AtomicActor._atomic
    def __setitem__(self, i: int, value):
        """Sets an index's position in the circular list.

        >>> c = CircularList(4)
        >>> c.update([1,2])
        >>> c[1] = 0
        >>> c
        [1, 0]
        >>> c[2] = 3 # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index is out of bounds
        >>> c[1] = CircularList.Empty() # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: list element cannot be of the CircularList.Empty class
        >>> c.update([4, 5, 6, 7])
        >>> c[2] = 1
        >>> c
        [4, 5, 1, 7]
        """
        i = self._convert_index(i)
        item = self.data[i]
        if isinstance(item, CircularList.Empty):
            raise IndexError("Index is out of bounds")
        if isinstance(value, CircularList.Empty):
            raise ValueError(
                "list element cannot be of the CircularList.Empty class")
        self.data[i] = value

    @AtomicActor._atomic
    def __contains__(self, value):
        if isinstance(value, CircularList.Empty):
            raise ValueError(
                "list element cannot be of the CircularList.Empty class")
        return value in self.data

    @AtomicActor._atomic
    def __reversed__(self):
        c = CircularList(self.size)
        c.update(reversed(self.data))
        return c

    @AtomicActor._atomic
    def clear(self):
        n = self.__len__()
        for i in range(n):
            self.pop()

    @AtomicActor._atomic
    def copy(self):
        c = CircularList(self.size)
        c.update(c.to_list())
        return c

    @AtomicActor._atomic
    def extend(self, iterable):
        self.update(iterable)

    @AtomicActor._atomic
    def count(self, value):
        """"""
        return self.to_list().count(value)  # TODO: Optimize this

    @AtomicActor._atomic
    def index(self, value):
        """"""
        return self.to_list().index(value)  # TODO: Optimize this

    def remove(self, value):
        """"""
        raise Exception("Unimplemented function")

    def reverse(self):
        """"""
        raise Exception("Unimplemented function")

    def sort(self):
        """"""
        raise Exception("Unimplemented function")


class WindowedFilter(AtomicActor):
    def __init__(self, window_size=10):
        if type(window_size) != int or window_size <= 0:
            raise RuntimeError(
                "window_size is an invalid value. Must be a positive integer.")

        self.window_size = window_size
        self.queue = deque()
        self.circ = CircularList(self.window_size)

    def __appender__(self, in_value, out_value):
        """The method to be overriden, when subclassing WindowedFilter.

        in_value - the new value being appended
        out_value - the old value that is removed from window
        """
        return in_value

    def get_inner_list(self):
        return self.circ.to_list()

    def to_list(self):
        return list(self.queue)

    def get_value(self):
        if self.queue:
            return self.queue[-1]
        else:
            return None

    def append(self, value, **kwargs):
        out_value = self.circ.append(value)
        if isinstance(out_value, CircularList.Empty):
            out_value = None
        in_value = self.__appender__(value, out_value, **kwargs)
        self.queue.append(in_value)

    def pop(self):
        try:
            out_value = self.circ.pop()
        except:
            out_value = None
        if isinstance(out_value, CircularList.Empty):
            out_value = None
        _ = self.__appender__(None, out_value)
        try:
            return self.queue.pop()
        except:
            return None

    def clear(self):
        while self.pop() is not None:
            pass
        self.queue.clear()

    def __repr__(self):
        return str(list(self.queue))


class MeanWindow(WindowedFilter):
    def __init__(self, window_size=10):
        super().__init__(window_size)
        self.running_sum = 0
        self.running_n = 0

    def __appender__(self, in_value, out_value):
        if out_value is not None:
            self.running_sum -= out_value

        if in_value is not None:
            self.running_sum += in_value

        self.running_n = min(self.window_size, self.running_n + 1)
        return self.running_sum / self.running_n


class SumWindow(WindowedFilter):
    def __init__(self, window_size=10):
        super().__init__(window_size)
        self.running_sum = 0

    def __appender__(self, in_value, out_value):
        if out_value is not None:
            self.running_sum -= out_value
        if in_value is not None:
            self.running_sum += in_value

        return self.running_sum


class MedianWindow(WindowedFilter):
    def __init__(self, window_size=10):
        super().__init__(window_size)
        self.data = []

    def __appender__(self, in_value, out_value):
        if out_value is not None:
            self.data.remove(out_value)
        if in_value is not None:
            self.data.append(in_value)
        self.data.sort()
        return median(self.data)


class IntegrationTracker(WindowedFilter):
    def __init__(self, default_dx=1):
        super().__init__(window_size=1)
        self.default_dx = default_dx

    def __appender__(self, in_value, out_value, dx=None):
        if dx is None:
            dx = self.default_dx
        old = self.get_value()
        old = 0 if old is None else old

        if out_value is None:
            return old
        elif in_value is None:
            # Popping the value
            return old
        else:
            return (out_value + in_value) / 2 * dx + old


class ValueListWrapper(UserList):
    def __init__(self, iterable=None):
        super().__init__(None)

        if iterable is not None:
            iter(iterable)
            self.data = iterable

    def get_value(self):
        return self[-1]


class SimpleFunctionFilter:
    def __init__(self, value_giver, func=None):
        if not (hasattr(value_giver, 'get_value') and callable(getattr(value_giver, 'get_value'))):
            raise RuntimeError(
                "value_giver does not have a valid get_value function")
        self.src = value_giver
        if func is None:
            self.func = lambda x: x
        else:
            self.func = func
        if not callable(func):
            raise RuntimeError(
                "inner function func is not a callable function")

    def get_value(self):
        value = self.src.get_value()
        if value is not None:
            return self.func(value)
        else:
            return None


class RangeLimitFilter(SimpleFunctionFilter):
    def __init__(self, source, lower, upper):
        super().__init__(source, lambda x: range_limit(x, lower, upper))


class ModulusFilter(SimpleFunctionFilter):
    def __init__(self, source, mod):
        super().__init__(source, lambda x: x % mod)


class MaximumFilter(SimpleFunctionFilter):
    def __init__(self, source, maximum_value):
        super().__init__(source, lambda x: max(x, maximum_value))


class MinimumFilter(SimpleFunctionFilter):
    def __init__(self, source, minimum_value):
        super().__init__(source, lambda x: min(x, minimum_value))


if __name__ == '__main__':
    import doctest
    doctest.testmod()
</file>

<file path="utils/remote.py">
from typing import Literal
from . import brick
from . import dummy
from .rmi import RemoteClient, RemoteServer, isrelatedclass


class RemoteBrickClient(RemoteClient):
    def __init__(self, address, password, port=None, sock=None):
        super(RemoteBrickClient, self).__init__(address, password, port, sock)
        self._brick: dummy.Brick = self.create_caller(
            dummy.Brick(), var_name='brick')

    def get_brick(self):
        return self._brick

    def make_remote(self, sensor_or_motor, *args, **kwargs):
        """Creates a remote sensor or motor that is attached to the remote brick.
        sensor_or_motor - A class, such as Motor or EV3UltrasonicSensor
        *args - any of the normal arguments that would be used to create the object locally

        Returns None if you gave the wrong class.
        """
        if isrelatedclass(sensor_or_motor, (brick.Motor, brick.Sensor)):
            kwargs.update({'bp': self._brick})
            return sensor_or_motor(*args, **kwargs)
        return None

    def set_default_brick(self):
        """Sets this RemoteBrickClient to be the default brick for all newly initialized motors or sensors.
        Use brick.restore_default_brick() to reset back to normal.

        This will only apply to newly created devices.

        Normal defined as:
        - The useless dummy brick on PCs
        - The actual BrickPi itself, if running this code on the BrickPi
        """
        brick.BP = self._brick


class RemoteBrickServer(RemoteServer):
    def __init__(self, password, port=None):
        super(RemoteBrickServer, self).__init__(password, port)
        self.register_object(brick.BP, var_name='brick')


class RemoteEV3UltrasonicSensor(brick.EV3UltrasonicSensor):
    def __init__(self, client: RemoteBrickClient, port: Literal[1, 2, 3, 4], mode="cm"):
        super(RemoteEV3UltrasonicSensor, self).__init__(
            port, mode=mode, bp=client.get_brick())


class RemoteEV3ColorSensor(brick.EV3ColorSensor):
    def __init__(self, client: RemoteBrickClient, port: Literal[1, 2, 3, 4], mode="component"):
        super(RemoteEV3ColorSensor, self).__init__(
            port, mode=mode, bp=client.get_brick())


class RemoteEV3GyroSensor(brick.EV3GyroSensor):
    def __init__(self, client: RemoteBrickClient, port: Literal[1, 2, 3, 4], mode="both"):
        super(RemoteEV3GyroSensor, self).__init__(
            port, mode=mode, bp=client.get_brick())


class RemoteTouchSensor(brick.TouchSensor):
    def __init__(self, client: RemoteBrickClient, port: Literal[1, 2, 3, 4], mode: str = "touch"):
        super(RemoteTouchSensor, self).__init__(
            port, mode=mode, bp=client.get_brick())


class RemoteMotor(brick.Motor):
    def __init__(self, client: RemoteBrickClient, port: Literal["A", "B", "C", "D"]):
        super(RemoteMotor, self).__init__(port, bp=client.get_brick())
</file>

<file path="utils/rmi.py">
try:
    from math import inf
except:
    inf = float('inf')
from queue import Queue
import socket
import _socket
import sys
import threading
import time
from collections import deque
from typing import Dict, List
import uuid

import json
import marshal
import pickle


TIMEOUT = socket.getdefaulttimeout()
DEFAULT_PORT = 2110
THREAD_SLEEP = 0.001
BUSY_WAITING = 0.001
DEFAULT_PASSWORD = 'password'
SERVER_START_RETRIES = 5
DEBUG_DEFAULT = False


def isrelatedclass(typ, cls):
    """Determines if typ is a subclass, superclass, or equivalent to cls
    cls can be an iterable of classes/types.
    """
    if type(cls) == type:
        cls = [cls]

    for t in cls:
        if typ == cls or issubclass(typ, cls) or issubclass(cls, typ):
            return True
    return False


class IdentifyingException(Exception):
    """An exception with an overriden string representation, giving its class name along with error message."""

    def __repr__(self):
        return f'{self.__class__.__name__}: {super(IdentifyingException, self).__repr__()}'


class UnsupportedCommand(IdentifyingException):
    """Error given for when a command was sent to a RemoteServer that cannot process it."""
    pass


class brickle:
    """A replacement for pickle, in the context of this RemoteClient/Server library. 
    Only allows the parsing of objects that subclass PasswordProtected.
    Attributes of these objects can only be primitive values. 
    The parse can be changed to utilize the slower pickle library to cover all value types."""
    _parser = marshal

    class UnpicklingError(IdentifyingException):
        pass

    def dumps(obj):
        """Only accepts objects that are of the type PasswordProtected, and converts them to a bytes-like format"""
        try:
            res = {}
            if isinstance(obj, PasswordProtected):
                res = brickle._dumps(obj)
            else:
                pass
            return brickle._parser.dumps(res)
        except Exception as err:
            raise brickle.UnpicklingError(err)

    def _dumps(obj):
        res = vars(obj).copy()
        res['__class__'] = obj.__class__.__name__
        return res

    def loads(data):
        """Only accepts data of the bytes-like format used by this class. 
        Outputs objects that are of the Command or Message type.

        Returns None for any other type.
        """
        try:
            data = brickle._parser.loads(data)
            if data['__class__'] == 'Command':
                c = Command(data['func_name'])
                return brickle._loads(c, data)
            elif data['__class__'] == 'Message':
                m = Message(data['text'])
                return brickle._loads(m, data)
            else:
                return None
        except Exception as err:
            raise brickle.UnpicklingError(err)

    def _loads(obj, data):
        # Specific to this implementation
        del data['__class__']
        obj.__dict__.update(data)
        return obj


class PasswordProtected:
    def __init__(self, password=None):
        if password is None:
            password = DEFAULT_PASSWORD
        self.password = password

    def verify_password(self, test):
        """Verifies that the test input matches the stored internal password"""
        return test == self.password


class MessageReplyException(IdentifyingException):
    pass


class Message(PasswordProtected):
    """Objects of this class are used as a wrapper around text messages sent over a TCP socket.

    Utilized mainly by the Connection, RemoteClient, and RemoteServer classes in this module.
    """

    def __init__(self, text):
        super(Message, self).__init__()
        self.text = str(text)
        self.sender = None

    def reply(self, text):
        """Sends a reply to the original sender of this message. Accepts a string text message.

        This action is not always available, and would raise a MessageReplyException if it isn't available.

        The underlying sender is intended to be Connection objects, but can apply to anything
        that has a send method that can handle a Message obj.
        """
        if self.sender is not None and hasattr(self.sender, 'send') and callable(getattr(self.sender, 'send')):
            self.sender.send(Message(text))
        else:
            raise MessageReplyException("No sender available")

    def __repr__(self):
        return self.text


class Command(PasswordProtected):
    """An object that represents a function call along with its arguments.
    It is intended for usage in communicating the data of remote function calls over sockets.

    Utilized mainly by the Connection, RemoteClient, and RemoteServer classes in this module.
    """

    def __init__(self, func_name, *args, **kwargs):
        """Accepts the function name and arguments of the function call."""
        super(Command, self).__init__()
        self.func_name = func_name
        self.args = args
        self.kwargs = kwargs
        self.id = str(uuid.uuid1())
        self.result = None
        self._result_given = False
        self._result_exception = False

    def __repr__(self):
        return f"{self.id}: {self.func_name}({self.args},{self.kwargs})"


class Debuggable:
    """An extra class utilized for displaying debug messages"""
    DEBUG_ALL = {}
    DEBUG_COUNTER = 0

    def __init__(self, debug=None):
        self.debug = DEBUG_DEFAULT if debug is None else debug
        if self.debug:
            i = id(self)
            if i not in self.__class__.DEBUG_ALL:
                self.__class__.DEBUG_ALL[i] = f'{self.__class__.__name__}{self.__class__.DEBUG_COUNTER}'
                self.__class__.DEBUG_COUNTER += 1

    def _debug(self, text):
        if self.debug:
            i = self.__class__.DEBUG_ALL[id(self)]
            print(f'>>> ({i}) {text}\t', file=sys.stderr)


class ConnectionListenerError(IdentifyingException):
    """An error displayed when an error occurs on the Connection listener execution"""
    pass


class ConnectionFatalError(IdentifyingException):
    """An error displayed when a bad error occurs related to the operation of the Remote server"""
    pass


class Connection:
    """Objects that wrap TCP sockets and create a thread to listen for received data.
    It also allows for listeners to be added, that process the data when it is received.
    """

    def __init__(self, sock, password="password", debug=None):
        self.sock: socket.socket = sock
        self.listeners = {}
        self.run_event = threading.Event()
        self.lock_listener = threading.Lock()
        self.lock_send = threading.Lock()
        self._isclosed = False

        self.password = password
        self.run_event.set()
        t = threading.Thread(target=Connection._func,
                             args=(self,), daemon=True)
        t.start()

    def _func(self):
        # self._debug('starting connection thread')
        while self.run_event.is_set():
            try:
                # self._debug('start receiving')
                try:
                    d = self.sock.recv(4096)
                except:
                    # The read failed because the connection probably died.
                    self.close()
                    break
                # self._debug('received. loading...')
                if len(d) <= 0:
                    self.run_event.clear()
                    self.close()
                    break
                o = brickle.loads(d)
                # self._debug('received. loaded...')

                self.lock_listener.acquire()

                if isinstance(o, PasswordProtected) and o.verify_password(self.password):
                    for key, val in self.listeners.items():
                        listener, args = val
                        try:
                            # self._debug(f'running listener "{key}"')
                            listener(*args, o, self)
                            # self._debug(f'completed listener "{key}"')
                        except Exception as err:
                            c = ConnectionListenerError(
                                f"Error: Listener {key} - {err} {val}")
                            print(c, file=sys.stderr)
                self.lock_listener.release()
            except OSError as err:
                if self.isclosed():
                    return
                print('Warning:', err, file=sys.stderr)
            except brickle.UnpicklingError as err:
                print('Data Unpickling Error:', err, file=sys.stderr)
            except Exception as err:
                c = ConnectionFatalError(f'Bad Error: {err}')
                print(c, file=sys.stderr)
        # self._debug(f'connection thread ended')

    def send(self, obj):
        """Send an object over the Connection. Only accepts objects of the type PasswordProtected."""
        if isinstance(obj, PasswordProtected):
            self.lock_send.acquire()
            obj.password = self.password
            # self._debug(f'dumping data ({str(obj)})')
            d = brickle.dumps(obj)
            # self._debug(f'sending data dump ({str(obj)})')
            self.sock.send(d)
            # self._debug(f'data sent ({str(obj)})')
            self.lock_send.release()

    def register_listener(self, name, listener, args=None):
        """Expects a listener of function type:
        def func(*args, obj, connection)

        where obj is the unpickled object, at the time
        args are the arguments of the args tuple
        and connection refers to this Connection object
        """
        if args is None:
            args = tuple()

        self.lock_listener.acquire()
        self.listeners[name] = (listener, args)
        self.lock_listener.release()

    def __del__(self):
        self.close()

    def close(self):
        """Ends this connection's thread and closes the socket."""
        try:
            self.run_event.clear()
            self.sock.shutdown(socket.SHUT_RDWR)
            self.sock.close()
        except:
            pass

        self._isclosed = True

    def isclosed(self):
        """Checks if the socket is closed."""
        return self._isclosed


class MethodCallerException(IdentifyingException):
    """An error that occurs in the calling of methods on the host server."""
    pass


class _MethodCaller:
    """A class that wraps an object for remote method control.

    This MethodCaller object will accept Command objects, and execute the 
    Command's function call on the underlying wrapped object.
    """

    def __init__(self, obj, custom=None, var_name=''):
        """Create the wrapper around the object to be exposed for remote method control.
        By default, excludes any methods starting with two underscores '__'

        obj - the object to wrap
        custom - Either None (default), or a list of string names of functions that would
            also be included in the functions being exposed for remote method control.
        var_name - Acts as a key, that can represent the Remote Object. Helps avoid name conflicts.
        """
        if custom is None:
            custom = []

        self.cls = obj.__class__
        self.obj = obj
        self.var_name = var_name

        self.methods = {f'{self.var_name}.{func_name}': getattr(self.cls, func_name) for func_name in dir(
            self.cls) if func_name in custom or (callable(getattr(self.cls, func_name)) and not func_name.startswith("__"))}

    def supports_command(self, command: Command):
        """Returns True if the function call of the Command is supported by this caller."""
        return command.func_name in self.methods

    def execute(self, command: Command):
        """Executes the Command on the underlying wrapped object. 

        If the command is not supported, the result is not set.
        If an exception occurs during execution, the Command's 
            result is set to the string representation of the Exception.
        """
        if command.func_name in self.methods:
            try:
                command.result = self.methods[command.func_name](self.obj,
                                                                 *command.args, **command.kwargs)
                command._result_given = True
            except Exception as err:
                command.result = str(MethodCallerException(err))
                command._result_exception = True
        return command


class MessageReceiver(object):
    """Subclass this class to add a thread-safe message buffer structure.
    Only provides methods for retrieving messages.

    Similar to a mixin, that addes the messages and lock_messages attributes, 
    and related functions for retrieving.
    """

    def __init__(self):
        self.messages = deque()
        self.lock_messages = threading.Lock()

    def wait_messages(self, timeout=None, wait_interval=None):
        """Busy waits for messages to arrive in the buffer.

        timeout - the number of seconds to wait for in total
        wait_interval - the sleep interval for a single iteration

        returns True whenever the function returns.
        """
        if timeout is None:
            timeout = inf
        if wait_interval is None:
            wait_interval = BUSY_WAITING

        timeout = int(timeout / wait_interval)

        while timeout > 0 and not self.has_messages():
            timeout -= 1
            time.sleep(wait_interval)
        return True

    def has_messages(self):
        """Checks if the buffer contains any messages."""
        return self.num_messages() > 0

    def num_messages(self):
        """Returns the number of messages in the buffer."""
        self.lock_messages.acquire()
        r = len(self.messages)
        self.lock_messages.release()
        return r

    def get_messages(self, count=0):
        """Gets the specified number of messages from the message buffer.

        Set to 0 (default value) to retrieve all the messages from the buffer.
        Thread-safe.
        """
        # Receiving messages in the listener thread for this RemoteBrickClient socket
        self.lock_messages.acquire()

        result = []
        if count <= 0:
            result = list(self.messages)
            self.messages.clear()
        elif count > 0:
            count = min(len(self.messages), count)
            for i in range(count):
                result.append(self.messages.popleft())

        self.lock_messages.release()
        return result

    def get_message(self, wait=False):
        """Retrieves one message from the buffer."""
        if wait:
            self.wait_messages()
        m = self._get_message()
        return m

    def _get_message(self):
        """Gets one message from the message buffer, or None if none present.
        Thread-safe.
        """
        self.lock_messages.acquire()
        try:
            m = self.messages.popleft()
        except:
            m = None
        self.lock_messages.release()
        return m


class _RemoteCaller:
    """A class that wraps a representative object to be the remote method controller.

    Usual method calls on this RemoteCaller object will send a Command object 
    through the associated RemoteClient object, instead of executing the usual method call.
    It will then wait for a response from the RemoteClient object, and return the result of that instead.
    """
    TESTING = False

    def create_caller(obj, remote_client, custom=None, var_name=''):
        """Alters the given object (obj) such it represents a Remote Object.

        Its functions will be modified to instead send Command objects through the RemoteClient (remote_client).

        obj - the object to be altered to represent the Remote Object. Should be of the same type as the Remote Object.
            This action relies on this obj having at least the same methods as the Remote Object.
        remote_client - the RemoteClient object that commands will be sent through
        custom - Either None (default), or a list of string names of functions that would
            also be included in the functions being exposed for remote method control.
        var_name - Acts as a key, that can represent the Remote Object. Helps avoid name conflicts.
        """
        caller = _RemoteCaller(remote_client, var_name)

        if custom is None:
            custom = []

        for name in dir(obj):
            attr = getattr(obj, name)
            if name in custom or (callable(attr) and not name.startswith('__')):
                setattr(obj, name, caller._generate(name))

        obj.__remote__ = caller
        return obj

    def __init__(self, remote_client, var_name):
        self.remote_client = remote_client
        self.var_name = var_name

    def _generate(self, func_name):
        """Creates special methods that replace the existing methods in the remote object."""
        func_name = f'{self.var_name}.{func_name}'

        def func(*args, wait_for_data=60, **kwargs):
            res = self.remote_client._send_command(
                func_name, *args, wait_for_data=wait_for_data, **kwargs)
            if _RemoteCaller.TESTING:
                return res
            else:
                if hasattr(res, 'result'):
                    return res.result
                else:
                    return res
        return func


class RemoteException(Exception):
    """Exception for when an exception occurs on a RemoteServer and it is sent back to the RemoteClient"""
    pass


class RemoteClient(MessageReceiver):
    """The client for remote method invocation.

    Objects of this class can send and receive textual messages 
    to the host, and create remote objects using the RemoteClient.create_caller method.
    create_caller takes in an object (ideally of the same type as the remote object) and 
    changes all of its methods such that they send function calls to the host and wait 
    for responses from the host for return values.
    """

    TESTING = False

    def __init__(self, address, password, port=None, sock=None):
        """Creates the client for remote method invocation.

        address - a string of either IP Address or Hostname of the Remote host
        password - the password used by the remote host
        port - None sets port to DEFAULT_PORT. Otherwise expects an integer value for port
            to connect to.
        sock - None creates a new socket based on the address and port. Otherwise, expects
            an opened socket that is ready for sending and receiving data.
        """
        super(RemoteClient, self).__init__()

        self.address = socket.gethostbyname(address)
        self.password = DEFAULT_PASSWORD if password is None else password
        self.port = DEFAULT_PORT if port is None else port

        self.buffer = {}
        self.lock_buffer = threading.Lock()

        self.status = None

        if sock is None:
            self.sock = socket.create_connection((self.address, self.port))
        else:
            self.sock = sock

        self.conn = Connection(self.sock, self.password)

        self.conn.register_listener('main', RemoteClient._listener, (self,))

    def create_caller(self, obj, custom=None, var_name=''):
        """Alters the given object (obj) such that it represents a Remote Object.

        Its functions will be modified to instead send Command objects through the RemoteClient (remote_client).

        obj - the object to be altered to represent the Remote Object. Should be of the same type as the Remote Object.
            This action relies on this obj having at least the same methods as the Remote Object.
        custom - Either None (default), or a list of string names of functions that would
            also be included in the functions being exposed for remote method control.
        var_name - Acts as a key, that can represent the Remote Object. Helps avoid name conflicts.
        """
        return _RemoteCaller.create_caller(obj, self, custom=custom, var_name=var_name)

    def send_message(self, text):
        """Sends a string text message to the host"""
        self.conn.send(Message(text))

    def __del__(self):
        self.close()

    def close(self):
        """Closes this connection to the host."""
        try:
            self.conn.close()
        except:
            pass

    def _listener(self, obj, conn):
        if isinstance(obj, Message):
            self.lock_messages.acquire()
            obj.sender = conn
            self.messages.append(obj)
            self.lock_messages.release()
        elif isinstance(obj, Command):
            self.lock_buffer.acquire()
            self.buffer[obj.id] = obj
            self.lock_buffer.release()
        else:
            pass

    def _send_command(self, func, *args, wait_for_data=True, **kwargs):
        """Send a command object to the other brick.
        Thread-safe.
        """
        c = Command(func, * args, **kwargs)
        self.conn.send(c)
        if wait_for_data:
            res = self._get_result(c.id, wait_for_data)
            if res._result_exception and not RemoteClient.TESTING:
                raise RemoteException(str(res.result))
        else:
            res = c.id

        return res

    def _get_result(self, cid, wait_for_data=True) -> Command:
        """Get the result of the following command id.
        Thread-safe.
        """
        waiting = not not wait_for_data
        if not isinstance(wait_for_data, (int, float)):
            wait_for_data = inf

        start = time.perf_counter()
        end = time.perf_counter()
        while waiting and wait_for_data > (end-start):
            self.lock_buffer.acquire()
            if cid in self.buffer:
                self.lock_buffer.release()
                break
            self.lock_buffer.release()

            time.sleep(BUSY_WAITING)
            end = time.perf_counter()

        self.lock_buffer.acquire()
        o = self.buffer.get(cid, None)
        if o is not None:
            del self.buffer[cid]
        self.lock_buffer.release()
        return o


class RemoteServer(MessageReceiver):
    """The client for remote method invocation.

    Objects of this class can broadcast and receive textual messages 
    to and from clients. Can accept objects to expose them 
    for remote control by clients through the register_object method. 

    Messages received from clients, will have the sender attribute set, 
    such that through these Message objects one can reply to the client.
    """

    def __init__(self, password, port=None):
        """Simply accepts the password to authenticate received objects.

        Optionally accepts a different port number. Expects type integer.
        Defualts to DEFAULT_PORT when port=None.
        """
        super(RemoteServer, self).__init__()
        self.password = (DEFAULT_PASSWORD if password is None else password)
        self.port = (DEFAULT_PORT if port is None else port)

        self._callers: List[_MethodCaller] = []
        self._caller_methods: Dict[str, _MethodCaller] = {}

        self._isclosed = False
        self.connections: List[RemoteClient] = []
        self.commands = []
        self.lock_commands = threading.Lock()
        self.lock_connections = threading.Lock()
        self.run_event = threading.Event()
        self.run_event.set()

        self.sock = None
        self.t1 = threading.Thread(target=self._thread_server, daemon=True)
        self.t1.start()

    def _thread_server(self):
        # True or False flag for server restartability on Linux.
        # Must be False on systems that don't support it e.g. Windows
        reuse_port = (hasattr(_socket, "SO_REUSEPORT"))

        while self.run_event.is_set():
            with socket.create_server(('0.0.0.0', self.port), reuse_port=reuse_port) as server:
                self.sock = server
                while self.run_event.is_set():
                    try:
                        conn, addr = self.sock.accept()  # blocking, don't need time sleep
                    except OSError:
                        self.run_event.clear()
                        break

                    self.lock_connections.acquire()
                    self.connections = list(
                        filter(lambda s: not s.isclosed(), self.connections))

                    connection = Connection(conn, self.password)
                    connection.register_listener(
                        'main', self._thread_listener)
                    self.connections.append(connection)
                    self.lock_connections.release()
                self.close_connections()
            self.close()

    def _thread_listener(self, obj, conn):
        if isinstance(obj, Command):
            self.lock_commands.acquire()
            self._execute(conn, obj)
            self.lock_commands.release()
        if isinstance(obj, Message):
            self.lock_messages.acquire()
            obj.sender = conn
            self.messages.append(obj)
            self.lock_messages.release()

    def register_object(self, obj, custom=None, var_name=''):
        """Accepts an object to be controlled by this remote method invocation host.

        Does not modify the object given.

        obj - the object to control
        custom - Either None (default), or a list of string names of functions that would
            also be included in the functions being exposed for remote method control.
        var_name - Acts as a key, that can represent the Remote Object. Helps avoid name conflicts.
        """
        caller = _MethodCaller(obj, custom=custom, var_name=var_name)
        for method in caller.methods:
            self._caller_methods[method] = caller
        self._callers.append(caller)

    def _caller_retrieve_command(self, command: Command) -> _MethodCaller:
        return self._caller_methods.get(command.func_name, None)

    def _caller_supports_command(self, command: Command):
        return command is not None and command.func_name in self._caller_methods.keys()

    def _caller_execute(self, command: Command):
        return self._caller_methods[command.func_name].execute(command)

    def _execute(self, conn: Connection, command: Command):
        """Executes a command and sends the result back to the remote brick (rem)"""
        command._result_given = True

        try:
            if (caller := self._caller_retrieve_command(command)) is not None:
                caller.execute(command)
                conn.send(command)
                return
            elif command.func_name == '__initialize':
                return
            elif command.func_name == '__verify':
                command.result = (
                    f"I am sending back the command for {command.id}")
                conn.send(command)
                return
            else:
                command.result = str(UnsupportedCommand(
                    f"Command '{command.func_name}' is not supported."))
        except Exception as err:
            command.result = str(f'{err.__class__.__name__}: {err}')

        command._result_exception = True
        conn.send(command)

    def __del__(self):
        self.close()

    def broadcast_message(self, text):
        """Send a singular message to all connected clients."""
        m = Message(text)
        self.lock_connections.acquire()
        for conn in self.connections:
            try:
                conn.send_message(m)
            except:
                pass
        self.lock_connections.release()

    def close_connections(self):
        """Close all client connections."""
        self.lock_connections.acquire()
        c = self.connections
        self.connections = []
        self.lock_connections.release()

        for conn in c:
            try:
                conn.close()
                del conn
            except:
                pass
        c.clear()

    def close(self):
        """Close this server and all client connections."""
        self._isclosed = True
        self.run_event.clear()
        self.close_connections()
        try:
            self.sock.shutdown(socket.SHUT_RDWR)
            self.sock.close()
        except:
            pass

    def isclosed(self):
        """Returns True if this server has been closed by .close()"""
        return self._isclosed
</file>

<file path="utils/telemetry.py">
"""
Module for providing access to a single, simple, GUI that can easily display data.
It also allows the creation of buttons and sliders for adjusting starting parameters.

Author: Ryan Au
"""

from collections import deque
from queue import Empty, Queue
from tkinter import Scale, ttk, StringVar, TclError, Button as TkButton

import tkinter as tk
from tkinter.constants import HORIZONTAL
import threading
from uuid import UUID, SafeUUID
import time

"""WINDOW - None when closed, Not None when open"""
WINDOW: tk.Tk = None

"""LABELS - filled with labels. {} when closed. {...} when open.
Should use WINDOW.destroy() to delete actual widgets in window.
"""
LABELS = {}

"""_EXIT_FLAG - True to when closed. False when open.
"""
_EXIT_FLAG = True

"""_TK_THREAD - Should be None when closed. No WINDOW to alter."""
_TK_THREAD = None

"""_USER_THREAD - Used for start_threaded.
None to start. Not None after a start_threaded.
_USER_THREAD.is_alive() is True while loop runs.
_USER_THREAD.is_alive() is False when the windowhas closed.
"""
_USER_THREAD = None


class Command:
    WAIT_DONE = 0.001

    def __init__(self, func, args):
        if not callable(func):
            raise RuntimeError("func is not a callable function")
        self.func = func
        self.args = args
        self.result_given = False
        self.error_given = False
        self.result = None
        # self.cid = UUID(is_safe=SafeUUID.safe)

    def execute(self):
        """To be executed in the main thread"""
        try:
            self.result = self.func(*(self.args))
            self.result_given = True
        except BaseException as e:
            self.result = e
            self.error_given = True

    def wait_done(self):
        """To be executed in the worker process"""
        while not self.result_given and not self.error_given:
            time.sleep(Command.WAIT_DONE)
        if self.result_given:
            return self.result
        if self.error_given:
            raise self.result


class CommandQueue:
    def __init__(self):
        self.queue = Queue()

    def put_func(self, func, args):
        c = Command(func, args)
        self.queue.put(c)
        return c

    def execute_all(self):
        size = self.queue.qsize()
        try:
            while size > 0:
                command: Command = self.queue.get(block=False)
                command.execute()
                size -= 1
        except Empty:
            pass


"""Commands function requests, from threads outside TK thread.
All commands are executed upon calls to telemetry.update()
"""
_COMMANDQUEUE = CommandQueue()


def remote(func, *args):
    """When outside the telemetry thread (thread where telemetry.start() executed)
    This will queue the function func for execution during the telemetry.update() call.
    """
    if _TK_THREAD is None or threading.current_thread().name == _TK_THREAD.name:
        raise RuntimeError(
            "Cannot run this function in the same thread as telemetry.update")
    c = _COMMANDQUEUE.put_func(func, args)
    return c.wait_done()


def remote_capable(func):
    """A function decorator, used to allow functions to run in both
    main telemetry thread and outside threads.
    """
    def inner(*args):
        if _TK_THREAD is None or threading.current_thread().name == _TK_THREAD.name:
            return func(*args)
        else:
            return remote(func, *args)
    return inner


def _on_closing():
    """Private method: cleans up internal values on window destruction"""
    global WINDOW, _EXIT_FLAG, LABELS, _TK_THREAD
    WINDOW.destroy()
    WINDOW = None
    _EXIT_FLAG = True
    _TK_THREAD = None
    LABELS = {}


def start():
    """Open the telemetry window.

    Thread that runs this function, will be called the telemetry thread.
    """
    global WINDOW, _EXIT_FLAG, _TK_THREAD
    _EXIT_FLAG = False
    if WINDOW is None:
        WINDOW = tk.Tk()
        _TK_THREAD = threading.current_thread()
    WINDOW.protocol("WM_DELETE_WINDOW", _on_closing)
    update()


def _start_threaded_target(pre_update_func, sleep_interval, *args):
    """Private method: the target function used in start_threaded."""
    try:
        start()
        while True:
            if not isopen():
                break
            pre_update_func()
            update()
            time.sleep(sleep_interval)
    except KeyboardInterrupt:
        pass


def start_threaded(pre_update_func=None, sleep_interval=0.01):
    """Starts the telemetry window in a separate thread.

    pre_update_func is a function with no arguments, which will be
    executed before every call to telemetry.update
    """
    global _USER_THREAD
    if pre_update_func is None:
        def func():
            pass
        pre_update_func = func
    if not callable(pre_update_func):
        raise RuntimeError("pre_update_func must be a callable function")
    if not isopen():
        _USER_THREAD = threading.Thread(target=_start_threaded_target, args=(
            pre_update_func, sleep_interval), daemon=True)
        _USER_THREAD.start()
        return True
    return False


def isopen():
    """Determines if the telemtry window has been opened or closed"""
    return not _EXIT_FLAG


@remote_capable
def resize(width=100, height=100):
    """Resize telemtry to a set width and height in pixels"""
    if WINDOW is None:
        return
    WINDOW.geometry("{}x{}".format(width, height))


@remote_capable
def stop():
    """Closes telemtry window"""
    if WINDOW is not None:
        _on_closing()


class _Updater:
    """Starts a thread with a constantly running while loop.
    While loop repeatedly runs the given func with the given arguments.
    """
    UPDATE_DELAY = 0.01

    def __init__(self, func, *args):
        self.thread = threading.Thread(
            target=self._listener, args=args, daemon=True)
        self.func = func
        self.event = threading.Event()
        self.event.set()

    def start(self):
        self.thread.start()

    def stop(self):
        self.event.clear()

    def _listener(self, *args):
        while self.event.is_set():
            try:
                (self.func)(*args)
                time.sleep(_Updater.UPDATE_DELAY)
            except BaseException as e:
                print(e)
                break


class _Updatable:
    """A class that inherits from this mixin gains two methods:
    set_updater and stop_updater

    set_updater will create an internal _updater varaible, and
        assign an _Updater object to it. The expected input function
        will always get the self as the first argument.

    stop_updater will stop the internal _updater if it isn't already
        stopped.
    """

    def set_updater(self, func, *args):
        """set_updater will create an internal _updater varaible, and
            assign an _Updater object to it. The expected input function
            will always get the self as the first argument.
        """
        if hasattr(self, '_updater') and self._updater is not None:
            if not isinstance(self._updater, _Updater):
                return  # Something went wrong, so we won't touch _updater anymore
            self._updater.stop()
        self._updater = _Updater(func, self, *args)
        self._updater.start()

    def stop_updater(self):
        """stop_updater will stop the internal _updater if it isn't already
        stopped.
        """
        if hasattr(self, '_updater') and self._updater is not None and isinstance(self._updater, _Updater):
            self._updater.stop()


class _Slider(_Updatable):
    """An internal _Slider object, that should not be instantiated
    using this class. Use telemetry.create_slider
    """

    def __init__(self, lower, upper, value, func=None):
        self.s = Scale(WINDOW, from_=lower, to=upper, orient=HORIZONTAL)
        self.s.set(value)
        self.s.pack()

        self.lower = lower
        self.upper = upper

        if func is not None:
            self.set_updater(func)

    @remote_capable
    def get_value(self):
        return self.s.get()

    @remote_capable
    def destroy(self):
        self.s.destroy()
        self.stop_updater()

    def __repr__(self):
        return f"Slider[{self.lower} <-> {self.upper}, {self.get_value()}]"


@remote_capable
def create_slider(lower, upper=None, value=None, func=None):
    """Adds a slider to the telemetry window AND returns the slider object added

    create_slider(50) creates: 0<---25--->50
    create_slider(25, 50) creates: 25<---37--->50
    create_slider(-100, 100, 50) creates: -100<---50--->100
    """
    if upper is None:
        upper = lower
        lower = 0

    if value is None:
        value = lower

    if WINDOW is None or not isopen():
        return

    return _Slider(lower, upper, value, func)


class _Button(_Updatable):
    """An internal _Button object, that should not be instantiated
    using this class. Use telemetry.create_button
    """

    def __init__(self, name, func=None):
        self.b = TkButton(WINDOW, text=name)
        self.b.bind("<ButtonPress>", self._on_press)
        self.b.bind("<ButtonRelease>", self._on_release)
        self.name = name
        self._is_pressed = False
        self.b.pack()

        if func is not None:
            self.set_updater(func)

    def _on_press(self, *args):
        self._is_pressed = True

    def _on_release(self, *args):
        self._is_pressed = False

    @remote_capable
    def is_pressed(self):
        return self._is_pressed

    @remote_capable
    def destroy(self):
        self.b.destroy()
        self.stop_updater()

    def __repr__(self):
        return f"Button[{self.name}, {self.is_pressed()}]"


@remote_capable
def create_button(name, func=None):
    """Adds a button to the telemetry window AND returns the button object added"""
    if WINDOW is None or not isopen():
        return

    return _Button(name, func)


def label(key, data, showkey=False):
    """Adds a textual Label based on a key to the telemetry window.

    If the key has not been used before, then it will create a new Label
    If the key has been used before, then it will change the old Label

    If showkey == True, then Label will have the format "key: data"
    If showkey == False, then Label will have the format "data" only
    """
    add(key, data, showkey)


@remote_capable
def add(key, data, showkey=False):
    """Adds a textual Label based on a key to the telemetry window.

    If the key has not been used before, then it will create a new Label
    If the key has been used before, then it will change the old Label

    If showkey == True, then Label will have the format "key: data"
    If showkey == False, then Label will have the format "data" only
    """
    if WINDOW is None or not isopen():
        return
    key = str(key)
    data = str(data)
    if showkey:
        data = "{} : {}".format(key, data)
    if key in LABELS:
        LABELS[key][1].set(data)
    else:
        var = StringVar()
        var.set(data)
        LABELS[key] = (tk.Label(WINDOW, textvariable=var), var)
        LABELS[key][0].pack()


def update(retries=1):
    """Updates the display, allowing it to function and respond to input/output.

    It also runs telemetry.remote commands
    """
    global WINDOW
    if WINDOW is not None:
        try:
            ### Execute CommandQueue Operations ###
            _COMMANDQUEUE.execute_all()
            ### Execute CommandQueue Operations ###
            if WINDOW is None or not isopen():
                return False
            for i in range(retries):
                WINDOW.update()
        except TclError as e:
            err = str(e)
            if err == 'can\'t invoke "update" command: application has been destroyed':
                WINDOW = None
        return True
    return False


def clear_labels():
    clear()


@remote_capable
def clear():
    """Destroy and remove all LABELS of the telemetry window"""
    global LABELS
    for i, widget in LABELS.items():
        try:
            widget[0].destroy()
        except TclError:
            pass
    LABELS = {}


def mainloop(pre_update_func=None, sleep_interval=0.01):
    """Starts a while loop that calls update for you! 
    Usage of telemetry.update not needed when using this

    pre_update_func is a function with no arguments, which will be
    executed before every call to telemetry.update
    """
    if pre_update_func is None:
        def func():
            pass
        pre_update_func = func
    if not callable(pre_update_func):
        raise RuntimeError("pre_update_func must be a callable function")
    if WINDOW is not None and isopen():
        _start_threaded_target(pre_update_func, sleep_interval)


if __name__ == '__main__':
    import time
    start()
    resize(500, 200)
    i = 0
    add("word", "heyo this is the start")
    update()
    while True:
        time.sleep(1)

        ### Test clearing window despite still updating ###
        if i == 10:
            clear()
            if not isopen():
                start()

        # Adding data
        add("color", "red", True)
        i = i + 2 if i < 40 else 0

        print(i, isopen())
        add("counter", "*"*i)

        # Must update window to see changes
        update()
</file>

<file path="README.md">
# esce211-final
</file>

<file path="unknown_color.csv">
228,262,108
229,263,109
230,263,107
226,261,106
231,263,108
234,265,108
236,269,111
234,268,107
233,269,109
238,268,110
223,258,105
230,263,108
244,274,112
242,272,112
246,274,112
245,274,113
246,274,113
242,273,110
238,269,111
233,265,108
</file>

<file path="src/constants.py">
"""
Centralized constants and tuning of constant during run time.
"""

# ======== Relevant Constants for Tuning =========


# ============= HARDWARE Ports =============
# Motor ports
LEFT_MOTOR_PORT = "B"
RIGHT_MOTOR_PORT = "D"
DROPPER_MOTOR_PORT = "A"

# Sensor ports
LEFT_COLOR_PORT = 1
RIGHT_COLOR_PORT = 2
ULTRASONIC_PORT = 3
TOUCH_PORT = 4

# ============= Motor Control Constants =============
# Basic movement parameters
MOTOR_POWER = 30.5  # Power percentage (0-100)
MOTOR_DPS = 180  # Degrees per second for speed-based control
SPEED_MODIFIER = 2  # Multiplier for MOTOR_DPS

# Time-based movement constants
FORWARD_TIME_PER_BLOCK = 2.28  # Time in seconds to move one block forward
TURN_90_TIME = 2.32  # Time in seconds for a 90-degree turn

# ============= Environment Constants =============
BLOCK_SIZE = 24  # cm per grid block
ALIGNMENT_TOLERANCE = 5  # cm tolerance for wall distance verification

# ============= Sampling Constants =============
NB_COLOR_SAMPLING = 20  # Number of samples for color sensor readings

# ============= Map / Grid Constants ============= (x,y)

GRID_WIDTH = 5
GRID_HEIGHT = 5

# 1 is hallway, 2 is burning room, 3 is avoid room. (flipped upside down because 0,0 is top left)
GRID_MAP = [
    [1, 1, 3, 3, 3],
    [1, 1, 3, 3, 3],
    [1, 1, 1, 1, 0],
    [3, 3, 2, 2, 2],
    [3, 3, 2, 2, 2]
]

FIRE_STATION = (0, 0)

HALLWAY_PATH = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2)]

ENTRANCE = (3, 2)  # Pos before burning room
BURNING_ROOM_ENTRY = (3, 3)  # First square of burning room

# SWeep of burning room (left to right circle)
BURNING_ROOM_SWEEP = [(2, 3), (2, 4), (3, 4), (4, 4), (4, 3), (3, 3), (2, 3)]

# Return path (opposite of path there)
RETURN_PATH = HALLWAY_PATH[::-1]

VALID_NEIGHBORS = {}
for y in range(GRID_HEIGHT):
    for x in range(GRID_WIDTH):
        if GRID_MAP[y][x] > 0:  # If valid position
            neighbors = []
            # Check all four directions
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nx, ny = x + dx, y + dy
                if (0 <= nx < GRID_WIDTH and 0 <= ny < GRID_HEIGHT and
                        GRID_MAP[ny][nx] > 0):
                    neighbors.append((nx, ny))
            VALID_NEIGHBORS[(x, y)] = neighbors

# ============= Monte Carlo Localization Constants =============
# Number of particles for Monte Carlo localization
MCL_PARTICLE_COUNT = 100
# Standard deviation for motion model (in grid units)
MCL_MOTION_NOISE = 0.1
# Standard deviation for sensor model (in cm)
MCL_SENSOR_NOISE = 5.0
# Weight threshold for resampling
MCL_RESAMPLING_THRESHOLD = 0.5

# ============= Calibration Constants =============
MAX_GRID_ALIGNMENT_ATTEMPTS = 10
MAX_ENTRANCE_ALIGNMENT_ATTEMPTS = 5

# =========== Timing Related Constants ========

EXPECTED_TIME_TO_BURNING_ROOM = 20

# ============= Direction Constants =============
NORTH = "NORTH"
SOUTH = "SOUTH"
EAST = "EAST"
WEST = "WEST"

DIRECTION_VECTORS = {
    NORTH: (0, 1),
    EAST: (1, 0),
    SOUTH: (0, -1),
    WEST: (-1, 0)
}

# ============= Color Constants =============
COLOR_BLACK = "black"
COLOR_ORANGE = "orange"
COLOR_RED = "red"
COLOR_GREEN = "green"
COLOR_YELLOW = "yellow"
COLOR_PURPLE = "purple"
COLOR_WHITE = "white"


class RuntimeConstants:
    """
    Runtime-adjustable constants that can be tuned during program execution.
    Use this class when you need to adjust parameters during runtime based on calibration.
    """

    def __init__(self):
        # Initialize with default values from the module constants
        self.motor_power = MOTOR_POWER
        self.motor_dps = MOTOR_DPS
        self.speed_modifier = SPEED_MODIFIER
        self.forward_time_per_block = FORWARD_TIME_PER_BLOCK
        self.turn_90_time = TURN_90_TIME

    def adjust_power(self, new_power):
        """Adjust motor power constant."""
        self.motor_power = new_power
        return self.motor_power

    def adjust_speed(self, new_dps):
        """Adjust motor speed in degrees per second."""
        self.motor_dps = new_dps
        return self.motor_dps

    def adjust_forward_time(self, new_time):
        """Adjust time required to move one block forward."""
        self.forward_time_per_block = new_time
        return self.forward_time_per_block

    def adjust_turn_time(self, new_time):
        """Adjust time required for a 90-degree turn."""
        self.turn_90_time = new_time
        return self.turn_90_time

    def calibrate_from_test(self, test_results):
        """
        Adjust parameters based on test results.

        Args:
            test_results: Dictionary with calibration results
        """
        if 'motor_power' in test_results:
            self.motor_power = test_results['motor_power']

        if 'forward_time' in test_results:
            self.forward_time_per_block = test_results['forward_time']

        if 'turn_time' in test_results:
            self.turn_90_time = test_results['turn_time']

        return {
            'motor_power': self.motor_power,
            'forward_time_per_block': self.forward_time_per_block,
            'turn_90_time': self.turn_90_time
        }
</file>

<file path="src/drive_system.py">
import logging
from src.constants import (
    MOTOR_DPS, MOTOR_POWER,
    NORTH, SOUTH, EAST, WEST, DIRECTION_VECTORS, TURN_90_TIME, FORWARD_TIME_PER_BLOCK
)
import time

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()],
)
logger = logging.getLogger("drive")


class DriveSystem:
    """Handles movement and orientation of the robot."""

    def __init__(self, left_motor, right_motor):
        self.left_motor = left_motor
        self.right_motor = right_motor

        # Initialize motors
        self.left_motor.reset_encoder()
        self.right_motor.reset_encoder()

        # Position tracking
        self.orientation = NORTH

        logger.info(
            f"Drive system initialized"
        )

    def reset_motors(self):
        """Stop all motors by setting DPS to 0."""
        self.left_motor.set_dps(0)
        self.right_motor.set_dps(0)
        logger.info("Motors reset")

    def set_motors_turn_left(self):
        """Set motors for left turn using power settings."""
        self.left_motor.set_power(-MOTOR_POWER)
        self.right_motor.set_power(MOTOR_POWER)
        logger.debug("Motors set for left turn")

    def set_motors_turn_right(self):
        """Set motors for right turn using power settings."""
        self.left_motor.set_power(MOTOR_POWER)
        self.right_motor.set_power(-MOTOR_POWER)
        logger.debug("Motors set for right turn")

    def advance_blocks(self, number):
        """Move forward a specified number of blocks based on tested timing values."""
        logger.info(f"Advancing {number} blocks")
        self.left_motor.set_dps(MOTOR_DPS)
        self.right_motor.set_dps(MOTOR_DPS)
        time.sleep(FORWARD_TIME_PER_BLOCK * number)
        self.reset_motors()

    def move_forward_slightly(self, time_seconds=0.5):
        """Move forward slightly for small adjustments."""
        logger.debug(f"Moving forward slightly for {time_seconds} seconds")
        self.left_motor.set_power(MOTOR_POWER / 2)
        self.right_motor.set_power(MOTOR_POWER / 2)
        time.sleep(time_seconds)
        self.reset_motors()

    def move_backward_slightly(self, time_seconds=0.5):
        """Move backward slightly for small adjustments."""
        logger.debug(f"Moving forward slightly for {time_seconds} seconds")
        self.left_motor.set_power(-MOTOR_POWER / 2)
        self.right_motor.set_power(-MOTOR_POWER / 2)
        time.sleep(time_seconds)
        self.reset_motors()

    def turn_90_left(self, times=1):
        """Turn left 90 degrees (or multiple of 90) based on tested timing values."""
        logger.info(f"Turning left {90 * times} degrees")
        self.set_motors_turn_left()
        time.sleep(TURN_90_TIME * times)
        self.reset_motors()

        # Update orientation
        directions = [NORTH, WEST, SOUTH, EAST]
        current_index = directions.index(self.orientation)
        new_index = (current_index + times) % 4
        self.orientation = directions[new_index]
        logger.info(f"New orientation: {self.orientation}")

    def turn_90_right(self, times=1):
        """Turn right 90 degrees (or multiple of 90) based on movement pattern."""
        logger.info(f"Turning right {90 * times} degrees")
        self.left_motor.set_power(MOTOR_POWER)
        self.right_motor.set_power(-MOTOR_POWER)
        time.sleep(TURN_90_TIME * times)
        self.reset_motors()

        # Update orientation
        directions = [NORTH, EAST, SOUTH, WEST]
        current_index = directions.index(self.orientation)
        new_index = (current_index + times) % 4
        self.orientation = directions[new_index]
        logger.info(f"New orientation: {self.orientation}")

    def turn_slightly_left(self, time_seconds=0.2):
        """Make a small left turn adjustment without changing orientation."""
        logger.debug(f"Turning slightly left for {time_seconds} seconds")
        self.set_motors_turn_left()
        time.sleep(time_seconds)
        self.reset_motors()

    def turn_slightly_right(self, time_seconds=0.2):
        """Make a small right turn adjustment without changing orientation."""
        logger.debug(f"Turning slightly right for {time_seconds} seconds")
        self.set_motors_turn_right()
        time.sleep(time_seconds)
        self.reset_motors()

    def turn(self, target_direction):
        """Turn to face a target direction (NORTH, SOUTH, EAST, WEST)."""
        if self.orientation == target_direction:
            logger.info(f"Already facing {target_direction}, no turn needed")
            return

        old_orientation = self.orientation

        directions = [NORTH, EAST, SOUTH, WEST]
        current_index = directions.index(self.orientation)
        target_index = directions.index(target_direction)

        # Calculates the shortest turn
        diff = (target_index - current_index) % 4
        if diff == 1:  # Turn right once
            self.turn_90_right()
        elif diff == 2:  # Turn 180 degrees (two right or two left)
            self.turn_90_right(2)
        elif diff == 3:  # Turn left once
            self.turn_90_left()

        logger.info(f"Turned from {old_orientation} to {self.orientation}")

    def stop(self):
        """Stop all movement."""
        self.reset_motors()
</file>

<file path="src/fire_extinguisher.py">
import logging
import time

from src.constants import DROPPER_MOTOR_PORT
from utils.brick import Motor

logger = logging.getLogger("extinguisher")


class FireExtinguisher:
    """Handles the fire extinguishing mechanism."""

    def __init__(self, motor_port=DROPPER_MOTOR_PORT):
        """
        Initialize the fire extinguisher system.

        Args:
            motor_port: Port for the dropper motor
        """
        self.dropper_motor = Motor(motor_port)
        self.fires_extinguished = 0

        logger.info("Fire extinguisher initialized")

    def drop_cube(self):
        """Drop a foam cube to extinguish a fire."""
        logger.info("Dropping foam cube to extinguish fire")
        # Implementation of dropping mechanism - Rotates the motor to drop one sandbag
        self.dropper_motor.set_dps(-360)  # Rotate 180 degrees
        time.sleep(0.7)
        self.dropper_motor.set_dps(0)

        logger.info("Please pick up the Cube!")
        time.sleep(1)  # Wait for cube to drop

        self.fires_extinguished += 1
        logger.info(
            f"Fire extinguished. Total fires extinguished: {self.fires_extinguished}"
        )
        return True

    def get_fires_extinguished(self):
        """Return the count of fires extinguished."""
        return self.fires_extinguished

    def test_drop_mechanism(self):
        """Test the cube dropping mechanism without incrementing the counter."""
        logger.info("Testing drop mechanism")

        # Execute drop
        self.dropper_motor.set_dps(-360)
        time.sleep(0.7)
        self.dropper_motor.set_dps(0)

        logger.info("Drop mechanism test completed")
        return True
</file>

<file path="src/navigation.py">
"""
Enhanced navigation module with robust positioning and error correction.
"""
import logging
import time
import math
import random
from collections import deque

from src.constants import (
    MAX_GRID_ALIGNMENT_ATTEMPTS, MAX_ENTRANCE_ALIGNMENT_ATTEMPTS, MCL_PARTICLE_COUNT,
    MCL_MOTION_NOISE, MCL_SENSOR_NOISE, MCL_RESAMPLING_THRESHOLD, BLOCK_SIZE,
    EAST, NORTH, WEST, SOUTH, DIRECTION_VECTORS, VALID_NEIGHBORS, GRID_MAP,
    GRID_HEIGHT, GRID_WIDTH, COLOR_ORANGE, COLOR_RED, COLOR_GREEN, COLOR_PURPLE,
    COLOR_YELLOW, COLOR_WHITE, ALIGNMENT_TOLERANCE
)

logger = logging.getLogger("navigation")


class Particle:
    """
    Represents a particle for Monte Carlo Localization (particle filter).
    """

    def __init__(self, x, y, orientation, weight=1.0):
        self.x = x
        self.y = y
        self.orientation = orientation
        self.weight = weight

    def __repr__(self):
        return f"Particle(x={self.x:.2f}, y={self.y:.2f}, orient='{self.orientation}', w={self.weight:.4f})"


class Navigation:
    """
    Navigation system which now includes position tracking, error correction,
    and sensor-based localization.
    """

    def __init__(self, drive_system, sensor_system):
        """
        Initialize navigation system.

        Args:
            drive_system: DriveSystem object for movement
            sensor_system: SensorSystem object for sensing
        """
        self.drive = drive_system
        self.sensors = sensor_system

        # Position tracking
        self.estimated_position = [0, 0]  # [x, y] in grid coordinates
        self.position_confidence = 1.0  # 0.0 to 1.0

        # Monte Carlo Localization
        self.particles = []
        self.initialize_particles()

        # Movement history for backtracking
        self.movement_history = deque(maxlen=10)

        # Last known valid position
        self.last_valid_position = [0, 0]
        self.last_valid_orientation = NORTH

        # Wall following state
        self.wall_following = False
        self.wall_side = None  # 'left' or 'right'

        # Path planning
        self.current_path = []

        logger.info("Enhanced navigation system initialized")

    def initialize_particles(self):
        """Initialize particles for Monte Carlo Localization."""
        self.particles = []
        for _ in range(MCL_PARTICLE_COUNT):
            # All particles start at the origin (0,0) facing NORTH
            self.particles.append(Particle(0, 0, NORTH, 1.0))
        logger.debug(f"Initialized {MCL_PARTICLE_COUNT} particles at origin")

    def update_particles_after_movement(self, dx, dy, rotation=None):
        """
        Update particle positions after movement.

        Args:
            dx: Change in x position
            dy: Change in y position
            rotation: New orientation if turned, or None if no turn
        """
        for particle in self.particles:
            # Apply motion model with noise
            noise_x = random.gauss(0, MCL_MOTION_NOISE)
            noise_y = random.gauss(0, MCL_MOTION_NOISE)

            if rotation:
                # If a rotation occurred, update orientation
                particle.orientation = rotation
                # Add small chance of wrong orientation after turn
                if random.random() < 0.05:  # 5% chance of error
                    orientations = [NORTH, EAST, SOUTH, WEST]
                    orientations.remove(rotation)
                    particle.orientation = random.choice(orientations)

            # Update position based on orientation and add noise
            if particle.orientation == NORTH:
                particle.y += dy + noise_y
                particle.x += noise_x
            elif particle.orientation == EAST:
                particle.x += dx + noise_x
                particle.y += noise_y
            elif particle.orientation == SOUTH:
                particle.y -= dy + noise_y
                particle.x += noise_x
            elif particle.orientation == WEST:
                particle.x -= dx + noise_x
                particle.y += noise_y

        logger.debug("Updated particles after movement")

    def update_particle_weights(self, sensor_measurements):
        """
        Update particle weights based on sensor measurements.

        Args:
            sensor_measurements: Dict of sensor readings
        """
        # Get wall distance measurement
        wall_distance = sensor_measurements.get('wall_distance')
        left_color = sensor_measurements.get('left_color')
        right_color = sensor_measurements.get('right_color')

        for particle in self.particles:
            # Start with current weight
            w = particle.weight

            # Check if particle is in valid position
            px, py = int(particle.x), int(particle.y)
            if not self._is_valid_position(px, py):
                particle.weight = 0.01  # Very low weight for invalid positions
                continue

            # Update weight based on wall distance if available
            if wall_distance is not None:
                expected_distance = self._expected_wall_distance(px, py, particle.orientation)
                if expected_distance is not None:
                    # Calculate weight based on difference between expected and measured
                    distance_diff = abs(wall_distance - expected_distance)
                    w *= math.exp(-distance_diff ** 2 / (2 * MCL_SENSOR_NOISE ** 2))

            # Update weight based on colors
            if left_color is not None and right_color is not None:
                expected_color = self._expected_color(px, py)
                if expected_color is not None:
                    # If colors match expectation, increase weight
                    if left_color == expected_color or right_color == expected_color:
                        w *= 1.5
                    else:
                        w *= 0.5

            particle.weight = max(0.001, w)  # Ensure minimum weight

        # Normalize weights
        total_weight = sum(p.weight for p in self.particles)
        if total_weight > 0:
            for particle in self.particles:
                particle.weight /= total_weight

        logger.debug("Updated particle weights based on sensor measurements")

    def resample_particles(self):
        """Resample particles based on weights using importance sampling."""
        # Calculate effective sample size to determine if resampling is needed
        weights = [p.weight for p in self.particles]
        effective_size = 1.0 / sum(w ** 2 for w in weights)

        # Only resample if effective size is below threshold
        if effective_size < MCL_PARTICLE_COUNT * MCL_RESAMPLING_THRESHOLD:
            # Create cumulative sum of weights for faster sampling
            cum_weights = []
            cum_sum = 0
            for w in weights:
                cum_sum += w
                cum_weights.append(cum_sum)

            # Resample using low variance sampler
            new_particles = []
            step = 1.0 / MCL_PARTICLE_COUNT
            offset = random.random() * step
            i = 0

            for m in range(MCL_PARTICLE_COUNT):
                u = offset + m * step
                while u > cum_weights[i]:
                    i += 1

                # Create new particle based on selected particle
                old = self.particles[i]
                new_particles.append(Particle(old.x, old.y, old.orientation, 1.0 / MCL_PARTICLE_COUNT))

            self.particles = new_particles
            logger.debug("Resampled particles")

    def update_position_estimate(self):
        """Update estimated position based on particle distribution."""
        if not self.particles:
            return

        # Calculate weighted average
        total_x = 0
        total_y = 0
        total_weight = 0

        for p in self.particles:
            total_x += p.x * p.weight
            total_y += p.y * p.weight
            total_weight += p.weight

        if total_weight > 0:
            avg_x = total_x / total_weight
            avg_y = total_y / total_weight

            # Find most common orientation
            orientation_counts = {
                NORTH: 0,
                EAST: 0,
                SOUTH: 0,
                WEST: 0
            }

            for p in self.particles:
                orientation_counts[p.orientation] += p.weight

            estimated_orientation = max(orientation_counts, key=orientation_counts.get)

            # Update estimated position
            self.estimated_position = [avg_x, avg_y]

            # Calculate position confidence based on particle dispersion
            variance_x = sum((p.x - avg_x) ** 2 * p.weight for p in self.particles) / total_weight
            variance_y = sum((p.y - avg_y) ** 2 * p.weight for p in self.particles) / total_weight
            std_dev = math.sqrt(variance_x + variance_y)

            # Map standard deviation to confidence (higher std_dev = lower confidence)
            self.position_confidence = max(0.0, min(1.0, 1.0 - std_dev / 2.0))

            # If confidence is high enough, update drive system position
            if self.position_confidence > 0.7:
                self.drive.update_position(
                    round(avg_x) - self.drive.position[0],
                    round(avg_y) - self.drive.position[1]
                )
                if self.drive.orientation != estimated_orientation:
                    logger.info(f"Correcting orientation from {self.drive.orientation} to {estimated_orientation}")
                    self.drive.orientation = estimated_orientation

            logger.debug(f"Updated position estimate to {self.estimated_position} "
                         f"with confidence {self.position_confidence:.2f}")

    def _expected_wall_distance(self, x, y, orientation):
        """
        Calculate expected distance to wall based on position and orientation.

        Args:
            x: Grid x coordinate
            y: Grid y coordinate
            orientation: Facing direction

        Returns:
            float: Expected distance to wall in cm, or None if unknown
        """
        if not (0 <= x < GRID_WIDTH and 0 <= y < GRID_HEIGHT):
            return None

        # Calculate distance to wall based on map
        distance = 0
        dx, dy = DIRECTION_VECTORS[orientation]

        current_x, current_y = x, y
        while (0 <= current_x < GRID_WIDTH and
               0 <= current_y < GRID_HEIGHT and
               GRID_MAP[current_y][current_x] > 0):
            current_x += dx
            current_y += dy
            distance += 1

        # Convert to cm
        return distance * BLOCK_SIZE

    def _expected_color(self, x, y):
        """
        Determine expected color based on grid position.

        Args:
            x: Grid x coordinate
            y: Grid y coordinate

        Returns:
            str: Expected color, or None if unknown
        """
        if not (0 <= x < GRID_WIDTH and 0 <= y < GRID_HEIGHT):
            return None

        grid_value = GRID_MAP[y][x]

        # Map grid values to expected colors
        if grid_value == 1:
            return COLOR_WHITE  # Hallway
        elif grid_value == 2:
            return COLOR_PURPLE  # Burning room
        elif grid_value == 3:
            return COLOR_YELLOW  # Avoid room

        return None

    def _is_valid_position(self, x, y):
        """Check if a position is valid on the grid."""
        return (0 <= x < GRID_WIDTH and
                0 <= y < GRID_HEIGHT and
                GRID_MAP[y][x] > 0)

    def localize(self):
        """
        Perform active localization to determine position.
        This is called when position confidence is low.
        """
        logger.info("Performing active localization")

        # Get current sensor data
        sensor_data = self.sensors.get_sensor_data()

        # Update particles based on sensor data
        self.update_particle_weights(sensor_data)
        self.resample_particles()
        self.update_position_estimate()

        # If confidence is still low, perform movement to gather more data
        if self.position_confidence < 0.5:
            logger.info("Low position confidence, performing movement for localization")

            # Rotation provides lots of information for localization
            self.drive.turn_slightly_left(0.2)
            time.sleep(0.2)
            sensor_data = self.sensors.get_sensor_data()
            self.update_particle_weights(sensor_data)

            self.drive.turn_slightly_right(0.4)
            time.sleep(0.2)
            sensor_data = self.sensors.get_sensor_data()
            self.update_particle_weights(sensor_data)

            self.drive.turn_slightly_left(0.2)

            # Resample and update after movements
            self.resample_particles()
            self.update_position_estimate()

        # Report localization results
        logger.info(f"Localization complete - Estimated position: {self.estimated_position}, "
                    f"Confidence: {self.position_confidence:.2f}")

        # Save position if confidence is high
        if self.position_confidence > 0.7:
            self.last_valid_position = self.estimated_position.copy()
            self.last_valid_orientation = self.drive.orientation

        return self.position_confidence > 0.7

    def align_with_grid(self):
        """Align robot with black grid lines using both color sensors."""
        logger.info("Aligning with grid...")

        attempts = 0

        while attempts < MAX_GRID_ALIGNMENT_ATTEMPTS:
            on_black = self.sensors.is_on_black_line()

            if on_black[0]:  # First element is boolean success
                if on_black[1] == "both":
                    logger.info("Aligned with black grid line")
                    self.drive.stop()
                    return True
                elif on_black[1] == "left":
                    logger.debug("Left sensor on black, turning right slightly")
                    self.drive.turn_slightly_right(0.1)
                elif on_black[1] == "right":
                    logger.debug("Right sensor on black, turning left slightly")
                    self.drive.turn_slightly_left(0.1)
            else:
                logger.debug("No black detected, moving forward slowly")
                self.drive.move_forward_slightly(0.2)

            self.drive.stop()
            attempts += 1

        logger.warning(f"Failed to align with grid after {MAX_GRID_ALIGNMENT_ATTEMPTS} attempts")
        return False

    def align_with_entrance(self):
        """Attempt to align with the orange entrance line."""
        logger.info("Trying to align with orange entrance line...")

        attempts = 0

        while attempts < MAX_ENTRANCE_ALIGNMENT_ATTEMPTS:
            found_orange, side = self.sensors.check_for_entrance()

            if found_orange:
                if side == "left":
                    logger.info("Orange line detected on left, adjusting position")
                    self.drive.turn_slightly_left(0.1)
                    self.drive.move_forward_slightly(0.3)
                elif side == "right":
                    logger.info("Orange line detected on right, adjusting position")
                    self.drive.turn_slightly_right(0.1)
                    self.drive.move_forward_slightly(0.3)

                # Check if both sensors are now on the orange line
                found_orange_again, new_side = self.sensors.check_for_entrance()
                if found_orange_again and new_side == "both":
                    # Both sensors now on the line
                    logger.info("Successfully aligned with orange entrance line")
                    return True
            else:
                # No orange detected, make small search movements
                logger.info("No orange line detected, searching...")

                # Try alternating small turns / forward movements
                if attempts % 2 == 0:
                    self.drive.turn_slightly_left(0.1)
                else:
                    self.drive.turn_slightly_right(0.1)

                self.drive.move_forward_slightly(0.2)

            attempts += 1

        logger.warning("Failed to align with entrance after multiple attempts")
        return False

    def verify_position_with_ultrasonic(self, expected_distance=None):
        """
        Verify position using ultrasonic sensor and walls.

        Args:
            expected_distance: Expected distance to wall

        Returns:
            bool: True if position verified, False otherwise
        """
        if not self.sensors.has_ultrasonic:
            logger.warning("Cannot verify position without ultrasonic sensor")
            return False

        # Get current distance
        dist = self.sensors.get_wall_distance()
        if dist is None:
            logger.warning("Ultrasonic sensor failed to return a distance")
            return False

        # If expected distance is explicitly provided, use it
        if expected_distance is not None:
            match = abs(dist - expected_distance) < ALIGNMENT_TOLERANCE
            logger.info(
                f"Position verification: measured {dist}cm, expected {expected_distance}cm, {'valid' if match else 'invalid'}")
            return match

        # Otherwise, try to estimate expected distance based on position and orientation
        expected = self._expected_wall_distance(
            int(self.estimated_position[0]),
            int(self.estimated_position[1]),
            self.drive.orientation
        )

        if expected is not None:
            match = abs(dist - expected) < ALIGNMENT_TOLERANCE
            logger.info(
                f"Position verification: measured {dist}cm, expected {expected}cm, {'valid' if match else 'invalid'}")
            return match

        logger.info(f"Wall distance: {dist}cm (no verification possible)")
        return True

    def navigate_to(self, target_x, target_y, avoid_obstacles=True):
        """
        Navigate to a target position with obstacle avoidance and position verification.

        Args:
            target_x: Target x coordinate
            target_y: Target y coordinate
            avoid_obstacles: Whether to check for and avoid obstacles

        Returns:
            bool: True if navigation successful, False otherwise
        """
        # First, localize to ensure we know our position
        if self.position_confidence < 0.7:
            self.localize()

        # Calculate path
        start_x, start_y = int(round(self.estimated_position[0])), int(round(self.estimated_position[1]))
        path = self._plan_path((start_x, start_y), (target_x, target_y))

        if not path:
            logger.warning(f"Could not find path to ({target_x}, {target_y})")
            return False

        logger.info(f"Planned path to ({target_x}, {target_y}): {path}")
        self.current_path = path

        # Follow path
        for i, (x, y) in enumerate(path[1:], 1):  # Skip start position
            prev_x, prev_y = path[i - 1]

            # Determine direction to move
            dx = x - prev_x
            dy = y - prev_y

            if dx == 1:  # Move east
                self.drive.turn(EAST)
            elif dx == -1:  # Move west
                self.drive.turn(WEST)
            elif dy == 1:  # Move north
                self.drive.turn(NORTH)
            elif dy == -1:  # Move south
                self.drive.turn(SOUTH)

            # Check for obstacles if enabled
            if avoid_obstacles and self.check_for_obstacle():
                logger.warning(f"Obstacle detected at ({prev_x}, {prev_y}) while moving to ({x}, {y})")
                success = self._avoid_obstacle()
                if not success:
                    logger.error("Failed to avoid obstacle, aborting navigation")
                    return False

                # Re-plan path after obstacle avoidance
                current_x, current_y = int(round(self.estimated_position[0])), int(round(self.estimated_position[1]))
                new_path = self._plan_path((current_x, current_y), (target_x, target_y))

                if not new_path:
                    logger.warning(f"Could not find new path to ({target_x}, {target_y}) after obstacle avoidance")
                    return False

                logger.info(f"Re-planned path: {new_path}")
                self.current_path = new_path

                # Start following the new path (recursively)
                return self.navigate_to(target_x, target_y, avoid_obstacles)

            # Move forward one block
            self.drive.advance_blocks(1)

            # Update particles based on movement
            self.update_particles_after_movement(dx, dy)

            # Get sensor readings and update position estimate
            sensor_data = self.sensors.get_sensor_data()
            self.update_particle_weights(sensor_data)
            self.resample_particles()
            self.update_position_estimate()

            # Verify position with ultrasonic sensor
            self.verify_position_with_ultrasonic()

            # Add to movement history for backtracking
            self.movement_history.append((prev_x, prev_y))

            # If position confidence is low, try to relocalize
            if self.position_confidence < 0.4:
                logger.warning("Position confidence low, attempting relocalization")
                if not self.localize():
                    logger.error("Failed to relocalize, aborting navigation")
                    return False

                # Check if we're significantly off course and need to replan
                current_x, current_y = int(round(self.estimated_position[0])), int(round(self.estimated_position[1]))
                if abs(current_x - x) > 0.5 or abs(current_y - y) > 0.5:
                    logger.warning(f"Off course: Expected ({x}, {y}), but at ({current_x}, {current_y})")

                    # Re-plan path from current estimated position
                    new_path = self._plan_path((current_x, current_y), (target_x, target_y))

                    if not new_path:
                        logger.warning(f"Could not find new path to ({target_x}, {target_y}) after relocalization")
                        return False

                    logger.info(f"Re-planned path: {new_path}")
                    self.current_path = new_path

                    # Start following the new path (recursively)
                    return self.navigate_to(target_x, target_y, avoid_obstacles)

        # End navigation - verify arrival at target
        current_x, current_y = int(round(self.estimated_position[0])), int(round(self.estimated_position[1]))
        success = abs(current_x - target_x) <= 0.5 and abs(current_y - target_y) <= 0.5

        if success:
            logger.info(f"Navigation complete, arrived at position ({current_x}, {current_y})")
        else:
            logger.warning(f"Navigation ended at ({current_x}, {current_y}), target was ({target_x}, {target_y})")

        return success

    def _plan_path(self, start, goal):
        """
        Plan a path from start to goal using A* algorithm.

        Args:
            start: Tuple (x, y) of start position
            goal: Tuple (x, y) of goal position

        Returns:
            list: List of (x, y) positions forming the path, or empty list if no path found
        """
        if not self._is_valid_position(start[0], start[1]) or not self._is_valid_position(goal[0], goal[1]):
            logger.warning(f"Invalid start {start} or goal {goal} position")
            return []

        # A* algorithm implementation
        open_set = {start}
        closed_set = set()

        came_from = {}

        g_score = {start: 0}
        f_score = {start: self._heuristic(start, goal)}

        while open_set:
            # Find node in open_set with lowest f_score
            current = min(open_set, key=lambda pos: f_score.get(pos, float('inf')))

            if current == goal:
                # We've reached the goal, reconstruct path
                path = [current]
                while current in came_from:
                    current = came_from[current]
                    path.append(current)
                return path[::-1]  # Reverse path to get start->goal

            open_set.remove(current)
            closed_set.add(current)

            # Check neighbors
            if current in VALID_NEIGHBORS:
                for neighbor in VALID_NEIGHBORS[current]:
                    if neighbor in closed_set:
                        continue  # Already evaluated

                    # Calculate tentative g_score
                    tentative_g = g_score[current] + 1  # Cost is 1 for each grid movement

                    if neighbor not in open_set:
                        open_set.add(neighbor)
                    elif tentative_g >= g_score.get(neighbor, float('inf')):
                        continue  # Not a better path

                    # This path is the best so far, record it
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = g_score[neighbor] + self._heuristic(neighbor, goal)

        # No path found
        logger.warning(f"No path found from {start} to {goal}")
        return []

    def _heuristic(self, a, b):
        """Manhattan distance heuristic for A* algorithm."""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def check_for_obstacle(self):
        """
        Check if there's an obstacle in the path.
        Uses ultrasonic sensor and color sensors.
        """
        # Check with ultrasonic sensor if available
        if self.sensors.has_ultrasonic:
            distance = self.sensors.get_wall_distance()
            if distance is not None and distance < BLOCK_SIZE - ALIGNMENT_TOLERANCE:
                logger.warning(f"Obstacle detected at distance {distance}cm")
                return True

        # Check with color sensors for furniture (green)
        found_furniture, _ = self.sensors.check_for_furniture()
        if found_furniture:
            logger.warning("Green furniture detected by color sensors")
            return True

        return False

    def _avoid_obstacle(self):
        """
        Smart obstacle avoidance strategy.

        Returns:
            bool: True if obstacle successfully avoided, False otherwise
        """
        logger.warning("Executing obstacle avoidance maneuver")

        # Remember original orientation
        original_orientation = self.drive.orientation

        # Get current position
        x, y = int(round(self.estimated_position[0])), int(round(self.estimated_position[1]))
        current_pos = (x, y)

        # Get direction we were trying to go
        dx, dy = DIRECTION_VECTORS[original_orientation]
        blocked_pos = (current_pos[0] + dx, current_pos[1] + dy)

        # Check if we have valid neighbors info for this position
        if current_pos in VALID_NEIGHBORS:
            neighbors = VALID_NEIGHBORS[current_pos]
            logger.info(f"Valid neighbors for position {current_pos}: {neighbors}")

            # Filter out the blocked position
            valid_moves = [pos for pos in neighbors if pos != blocked_pos]

            if valid_moves:
                # Pick the neighbor that's closest to our goal if we have a current path
                if self.current_path and len(self.current_path) > 0:
                    goal = self.current_path[-1]
                    valid_moves.sort(key=lambda pos: self._heuristic(pos, goal))

                next_x, next_y = valid_moves[0]
                logger.info(f"Selected alternative path to ({next_x}, {next_y})")

                # Determine direction to move
                move_dx = next_x - x
                move_dy = next_y - y

                if move_dx == 1:
                    self.drive.turn(EAST)
                elif move_dx == -1:
                    self.drive.turn(WEST)
                elif move_dy == 1:
                    self.drive.turn(NORTH)
                elif move_dy == -1:
                    self.drive.turn(SOUTH)

                # Ensure we're not still detecting the obstacle
                if self.check_for_obstacle():
                    logger.warning("Still detecting obstacle after turn, backing up slightly")
                    self.drive.move_backward_slightly(0.5)

                # Move forward
                self.drive.advance_blocks(1)

                # Update particles based on movement
                self.update_particles_after_movement(move_dx, move_dy)
                sensor_data = self.sensors.get_sensor_data()
                self.update_particle_weights(sensor_data)
                self.update_position_estimate()

                logger.info("Obstacle avoidance completed")
                return True

        # Fallback: try backing up and taking a different path
        logger.warning("No valid alternative path found, backing up")
        self.drive.turn(self._opposite_direction(original_orientation))
        self.drive.advance_blocks(1)

        # Update position estimate after backup
        dx, dy = DIRECTION_VECTORS[self._opposite_direction(original_orientation)]
        self.update_particles_after_movement(dx, dy)
        sensor_data = self.sensors.get_sensor_data()
        self.update_particle_weights(sensor_data)
        self.update_position_estimate()

        return False

    def _opposite_direction(self, direction):
        """Return the opposite direction."""
        opposites = {
            NORTH: SOUTH,
            SOUTH: NORTH,
            EAST: WEST,
            WEST: EAST
        }
        return opposites.get(direction, NORTH)

    def identify_room(self):
        """
        Identify the current room based on color patterns.
        Uses multiple samples for robustness.

        Returns:
            str: Room type ('burning room', 'avoid room', 'hallway', or 'unknown')
        """
        logger.info("Identifying current room")

        # Take multiple samples for reliability
        room_colors = []
        for _ in range(5):  # Increased samples for better accuracy
            left_color = self.sensors.get_color_left()
            right_color = self.sensors.get_color_right()
            if left_color:
                room_colors.append(left_color)
            if right_color:
                room_colors.append(right_color)
            time.sleep(0.1)

        # Count occurrences of each color
        color_counts = {}
        for color in room_colors:
            if color in color_counts:
                color_counts[color] += 1
            else:
                color_counts[color] = 1

        logger.info(f"Room color analysis: {color_counts}")

        # Determine room type based on color majority
        total_samples = len(room_colors)
        if total_samples == 0:
            return "unknown"

        # Calculate percentages of each color
        color_percentages = {color: count / total_samples * 100 for color, count in color_counts.items()}

        # Determine room type using thresholds
        if COLOR_PURPLE in color_percentages and color_percentages[COLOR_PURPLE] > 30:
            return "burning room"
        elif COLOR_YELLOW in color_percentages and color_percentages[COLOR_YELLOW] > 30:
            return "avoid room"
        elif COLOR_WHITE in color_percentages and color_percentages[COLOR_WHITE] > 30:
            return "hallway"
        else:
            # Try to match with expected color at current position
            x, y = int(round(self.estimated_position[0])), int(round(self.estimated_position[1]))
            expected = self._expected_color(x, y)

            if expected == COLOR_PURPLE:
                return "burning room"
            elif expected == COLOR_YELLOW:
                return "avoid room"
            elif expected == COLOR_WHITE:
                return "hallway"

        return "unknown"

    def find_fire(self):
        """
        Search for a fire in the current position.
        Performs a small search pattern if needed.

        Returns:
            tuple: (found_fire, sensor_side) - Boolean if fire found and which sensor(s)
        """
        logger.info("Searching for fire")

        # First, check if fire is directly visible
        found_fire, side = self.sensors.check_for_fire()
        if found_fire:
            logger.info(f"Fire detected on {side} side")
            return True, side

        # If not, perform a small search pattern
        logger.info("No fire immediately visible, performing search pattern")

        # Try looking left
        self.drive.turn_slightly_left(0.3)
        found_fire, side = self.sensors.check_for_fire()
        if found_fire:
            logger.info(f"Fire detected on {side} side after turning left")
            return True, side

        # Try looking right
        self.drive.turn_slightly_right(0.6)  # 0.3 back to center + 0.3 to right
        found_fire, side = self.sensors.check_for_fire()
        if found_fire:
            logger.info(f"Fire detected on {side} side after turning right")
            return True, side

        # Try looking forward with a small forward movement
        self.drive.turn_slightly_left(0.3)  # Back to center
        self.drive.move_forward_slightly(0.3)
        found_fire, side = self.sensors.check_for_fire()
        if found_fire:
            logger.info(f"Fire detected on {side} side after moving forward")
            return True, side

        # Move back to original position
        self.drive.move_backward_slightly(0.3)

        logger.info("No fire detected after search pattern")
        return False, "NONE"
</file>

<file path="src/sensor_system.py">
import logging
import math

from src.constants import (
    NB_COLOR_SAMPLING,
    COLOR_RED, COLOR_ORANGE, COLOR_GREEN
)
import src.color_matching as colo
from collections import deque
import time

logger = logging.getLogger("sensors")


class SensorSystem:
    """Handles all sensors and color detection."""

    def __init__(self, left_color_sensor, right_color_sensor, ultrasonic_sensor=None, touch_sensor=None):
        """
        Initialize the sensor system.

        Args:
            left_color_sensor: Left color sensor object
            right_color_sensor: Right color sensor object
            ultrasonic_sensor: Ultrasonic sensor object (optional)
            touch_sensor: Touch sensor object (optional)
        """
        # Initialize sensors
        self.left_color = left_color_sensor
        self.right_color = right_color_sensor
        self.touch_sensor = touch_sensor
        self.ultrasonic = ultrasonic_sensor

        # Wait for sensors to be ready
        self.left_color.wait_ready()
        self.right_color.wait_ready()
        if self.touch_sensor:
            self.touch_sensor.wait_ready()

        # Check if ultrasonic sensor is working
        self.has_ultrasonic = False
        if ultrasonic_sensor:
            try:
                self.ultrasonic.wait_ready()
                test_reading = self.ultrasonic.get_cm()
                if test_reading is not None:
                    self.has_ultrasonic = True
                    logger.info(f"Ultrasonic sensor initialized, test reading: {test_reading}cm")
            except Exception as e:
                logger.warning(f"Ultrasonic sensor initialization failed: {e}")

        # Sensor data filtering
        self.distance_history = deque(maxlen=5)  # Last 5 distance readings
        self.left_color_history = deque(maxlen=NB_COLOR_SAMPLING)  # Recent color detections
        self.right_color_history = deque(maxlen=NB_COLOR_SAMPLING)  # Recent color detections

        # Sensor calibration values
        self.ultrasonic_offset = 0  # Adjustment for ultrasonic readings
        self.color_confidence_threshold = 0.6  # Minimum confidence for color detection

        logger.info("Sensor system initialized")

    def get_color_left(self):
        """
        Get robust color reading from left color sensor using consensus.

        Returns:
            str: Detected color, or None if unreliable
        """
        # Clear history if it's getting too inconsistent
        if len(self.left_color_history) > NB_COLOR_SAMPLING // 2:
            if len(set(self.left_color_history)) > NB_COLOR_SAMPLING // 2:  # Too many different colors
                self.left_color_history.clear()

        # Get multiple RGB samples
        rgb_values = []
        for _ in range(NB_COLOR_SAMPLING):
            rgb = self.left_color.get_rgb()
            if rgb and len(rgb) == 3:  # Ensure valid RGB
                rgb_values.append(rgb)

        if not rgb_values:
            logger.warning("Left color sensor returned no valid RGB values")
            return None

        # Use color matching algorithm
        try:
            color_match = colo.match_unknown_color(rgb_values)
            confidence = self._calculate_color_confidence(rgb_values, color_match)

            # Add to history
            self.left_color_history.append(color_match)

            # Only return color if confidence is high enough
            if confidence >= self.color_confidence_threshold:
                logger.debug(f"Left color: {color_match} (confidence: {confidence:.2f})")
                return color_match
            else:
                # Use majority voting from history
                if self.left_color_history:
                    color_counts = {}
                    for color in self.left_color_history:
                        color_counts[color] = color_counts.get(color, 0) + 1
                    majority_color = max(color_counts, key=color_counts.get)
                    majority_count = color_counts[majority_color]

                    if majority_count >= len(self.left_color_history) * 0.6:  # At least 60% agreement
                        logger.debug(f"Left color (history majority): {majority_color}")
                        return majority_color

                logger.debug(f"Left color detection uncertain: {color_match} (confidence: {confidence:.2f})")
                return None
        except Exception as e:
            logger.error(f"Error in left color detection: {e}")
            return None

    def get_color_right(self):
        """
        Get robust color reading from right color sensor using consensus.

        Returns:
            str: Detected color, or None if unreliable
        """
        # Same approach as get_color_left
        if len(self.right_color_history) > NB_COLOR_SAMPLING // 2:
            if len(set(self.right_color_history)) > NB_COLOR_SAMPLING // 2:  # Too many different colors
                self.right_color_history.clear()

        rgb_values = []
        for _ in range(NB_COLOR_SAMPLING):
            rgb = self.right_color.get_rgb()
            if rgb and len(rgb) == 3:
                rgb_values.append(rgb)

        if not rgb_values:
            logger.warning("Right color sensor returned no valid RGB values")
            return None

        try:
            color_match = colo.match_unknown_color(rgb_values)
            confidence = self._calculate_color_confidence(rgb_values, color_match)

            self.right_color_history.append(color_match)

            if confidence >= self.color_confidence_threshold:
                logger.debug(f"Right color: {color_match} (confidence: {confidence:.2f})")
                return color_match
            else:
                if self.right_color_history:
                    color_counts = {}
                    for color in self.right_color_history:
                        color_counts[color] = color_counts.get(color, 0) + 1
                    majority_color = max(color_counts, key=color_counts.get)
                    majority_count = color_counts[majority_color]

                    if majority_count >= len(self.right_color_history) * 0.6:
                        logger.debug(f"Right color (history majority): {majority_color}")
                        return majority_color

                logger.debug(f"Right color detection uncertain: {color_match} (confidence: {confidence:.2f})")
                return None
        except Exception as e:
            logger.error(f"Error in right color detection: {e}")
            return None
    def _calculate_color_confidence(self, rgb_values, color_match):
        """
        Calculate confidence of color detection based on consistency.

        Args:
            rgb_values: List of RGB readings
            color_match: Detected color

        Returns:
            float: Confidence value from 0 to 1
        """
        # Use distance to color model center as confidence metric
        # This would be ideally calculated from color_matching module
        # For now, use a simple proxy: consistency of RGB values
        if not rgb_values:
            return 0

        # Calculate average RGB
        avg_r = sum(rgb[0] for rgb in rgb_values) / len(rgb_values)
        avg_g = sum(rgb[1] for rgb in rgb_values) / len(rgb_values)
        avg_b = sum(rgb[2] for rgb in rgb_values) / len(rgb_values)

        # Calculate variance (dispersion from average)
        var_r = sum((rgb[0] - avg_r) ** 2 for rgb in rgb_values) / len(rgb_values)
        var_g = sum((rgb[1] - avg_g) ** 2 for rgb in rgb_values) / len(rgb_values)
        var_b = sum((rgb[2] - avg_b) ** 2 for rgb in rgb_values) / len(rgb_values)

        total_variance = var_r + var_g + var_b

        # Convert to confidence (lower variance = higher confidence)
        # Scale to 0-1 range (heuristic: 5000 is typical max variance)
        max_expected_variance = 5000
        confidence = max(0, min(1, 1 - (total_variance / max_expected_variance)))

        return confidence

    def check_color_match(self):
        """Returns Tuple (bool Match, left color, right color)"""
        left_color = self.get_color_left()
        right_color = self.get_color_right()
        return left_color == right_color, left_color, right_color

    def check_for_color(self, target_color):
        """
        Check if either sensor reliably detects the target color.
        Uses majority voting for more reliable detection.
        Returns ( True if any, which sensors)
        """
        left_color = self.get_color_left()
        right_color = self.get_color_right()

        # Check which sensors detect the target color
        left_match = (left_color == target_color)
        right_match = (right_color == target_color)

        if left_match and right_match:
            return True, "BOTH"
        elif left_match:
            return True, "LEFT"
        elif right_match:
            return True, "RIGHT"
        else:
            return False, "NONE"

    def check_for_fire(self):
        """Check for red color (fire)."""
        return self.check_for_color(COLOR_RED)

    def check_for_entrance(self):
        """Check for orange color (entrance line)."""
        return self.check_for_color(COLOR_ORANGE)

    def check_for_furniture(self):
        """Check for green color (furniture)."""
        return self.check_for_color(COLOR_GREEN)

    def is_emergency_pressed(self):
        """Check if emergency button is pressed."""
        return self.touch_sensor.is_pressed()

    # Stuff for US
    def calibrate_ultrasonic(self, known_distance=None):
        """
        Calibrate ultrasonic sensor against a known distance.

        Args:
            known_distance: Actual distance in cm, if available
        """
        if not self.has_ultrasonic:
            logger.warning("Cannot calibrate: ultrasonic sensor not available")
            return

        # Take multiple readings
        readings = []
        for _ in range(10):
            dist = self.ultrasonic.get_cm()
            if dist is not None:
                readings.append(dist)
            time.sleep(0.1)

        if not readings:
            logger.warning("Calibration failed: no valid readings obtained")
            return

        # Calculate average reading
        avg_reading = sum(readings) / len(readings)

        # If known distance is provided, calculate offset
        if known_distance is not None:
            self.ultrasonic_offset = known_distance - avg_reading
            logger.info(f"Ultrasonic calibrated with offset {self.ultrasonic_offset}cm")
        else:
            # Just log the consistency of readings
            variance = sum((r - avg_reading) ** 2 for r in readings) / len(readings)
            std_dev = math.sqrt(variance)
            logger.info(f"Ultrasonic self-check: avg={avg_reading:.1f}cm, std_dev={std_dev:.1f}cm")

    def get_wall_distance(self):
        """
        Get filtered distance to nearest wall using ultrasonic sensor.
        Takes multiple readings and applies filtering ( this should be more reliable)
        """
        if not self.has_ultrasonic:
            logger.warning("Ultrasonic sensor not available")
            return None

        # Take multiple readings
        readings = []
        num_samples = 8  # Take 8 samples
        for _ in range(num_samples):
            try:
                raw_dist = self.ultrasonic.get_cm()
                if raw_dist is not None:
                    # Apply calibration offset
                    readings.append(raw_dist + self.ultrasonic_offset)
            except Exception as e:
                logger.debug(f"Error in ultrasonic reading: {e}")
            time.sleep(0.01)  # Small delay between readings

        if not readings:
            logger.warning("No valid ultrasonic readings obtained")
            return None

        # Remove outliers before averaging
        if len(readings) >= 4:
            readings.sort()
            # Remove lowest and highest values if we have enough readings
            trimmed_readings = readings[1:-1]
        else:
            trimmed_readings = readings

        # Calculate average from trimmed readings
        avg_dist = sum(trimmed_readings) / len(trimmed_readings)

        # Add to history for trend analysis
        self.distance_history.append(avg_dist)

        # Apply median filter to recent history for additional stability
        if len(self.distance_history) >= 3:
            sorted_history = sorted(self.distance_history)
            filtered_dist = sorted_history[len(sorted_history) // 2]  # Median

            # Calculate standard deviation to assess measurement stability
            variance = sum((r - avg_dist) ** 2 for r in trimmed_readings) / len(trimmed_readings)
            std_dev = math.sqrt(variance)

            stability = "stable" if std_dev < 2.0 else "unstable"
            logger.debug(
                f"Ultrasonic distance: {filtered_dist:.1f}cm (avg: {avg_dist:.1f}cm, σ: {std_dev:.1f}, {stability})")
            return filtered_dist
        else:
            logger.debug(f"Ultrasonic distance: {avg_dist:.1f}cm (based on {len(trimmed_readings)} readings)")
            return avg_dist
    def get_sensor_data(self):
        """    Get readings from all sensors for debugging and calibration.
    """
        data = {
            'left_color': self.get_color_left(),
            'right_color': self.get_color_right(),
            'emergency_pressed': self.is_emergency_pressed()
        }

        if self.has_ultrasonic:
            data['wall_distance'] = self.get_wall_distance()

        return data
</file>

<file path="src/siren_controller.py">
import logging
import threading
import time
from utils.sound import Song, Sound

logger = logging.getLogger("siren")


class SirenController:
    """Handles the creation and control of the siren sound."""

    def __init__(self):
        self.siren = None
        self.silence = None
        self.siren_low = None
        self.siren_high = None
        self.siren_thread = None
        self.siren_active = False
        self.create_siren()

    def create_siren(self):
        """Create the siren sound using the Sound module"""
        # Create high pitch siren sound
        # TODO: Make sound like siren.
        self.high_siren = Sound(
            duration=1.5,  # Longer duration for better wail effect
            volume=95,  # Loud volume for emergency alerts
            pitch="C6",  # High pitch base note
            cutoff=0.05,  # Slight softening at start/end
            fs=16000,  # Higher sample rate for better quality
            mod_f=2,  # Frequency modulation rate for wailing effect
            mod_k=20,  # Stronger frequency modulation for authentic sound
            amp_f=12,  # Amplitude modulation for wobble
            amp_ka=0.3,  # Medium amplitude variation
            amp_ac=0.8  # Overall amplitude control
        )

        # Create the siren using just the single modulated sound
        self.siren = Song([self.high_siren])
        self.siren.compile()
        logger.info("Fire siren created with single modulated tone")


    def start(self):
        """Start playing the siren in a separate thread"""
        if self.siren_thread is not None and self.siren_thread.is_alive():
            logger.info("Siren already playing")
            return

        self.siren_active = True
        self.siren_thread = threading.Thread(target=self._play_siren)
        self.siren_thread.daemon = (
            True  # Allow the thread to be terminated when the program exits
        )
        self.siren_thread.start()
        logger.info("Siren started")

    def stop(self):
        """Stop the siren"""
        if self.siren_thread is not None:
            self.siren_active = False
            self.siren.stop()
            logger.info("Siren stopped")

    def _play_siren(self):
        """Play the siren repeatedly until stopped"""
        while self.siren_active:
            self.siren.play()
            time.sleep(self.siren.duration)
            # The siren will automatically stop when the duration is up,
            # but we need to play it again if the siren is still active
            if not self.siren_active:
                break
</file>

<file path="utils/sound.py">
"""
#!/usr/bin/env python3
Module for creating and generating sine wave based sound.
Includes Frequency modulation and Amplitude modulation.

Authors: Ryan Au and Younes Boubekaur
"""

from typing import Callable, Iterable, SupportsIndex, Tuple, Union
import time
import os
import pickle
import simpleaudio as sa
import math
import functools
import array

LIMIT_MAX_VOLUME = True


def change_volume(percentage):
    vol = abs(int(percentage))
    vol = min(100, max(0, vol))
    try:
        command = f"sudo amixer cset numid=1 {vol}%"
        os.system(command)
    except OSError:
        return


@functools.lru_cache()
def sin(x: float) -> float:
    return math.sin(x)


def cos(x: float) -> float:
    return math.cos(x)


def clip(x: float, bot: float, top: float, nomax=False) -> float:
    # Ensures that x is no lesser than bot and no greater than top
    return max(x, bot) if nomax else max(min(x, top), bot)


def _amp_to_db(p0: float, p1: float) -> float:
    """Converts the relative amplitude to decibels.
    p0 is the reference amplitude, p1 is the next value
    """
    return 20 * math.log10(p1 / p0)


def db_to_amp(db: float, ref_amp: float) -> float:
    """Converts decibels to a next amplitude.
    ref_amp is the reference amplitude to start at.
    """
    return 10 ** (db / 20) * ref_amp


HIGHEST_VOLUME = 100  # Custom value. Could be 100, 1.0, 50, doesn't matter.
_LOWEST_AMPLITUDE = 0.0001  # must be non-zero, but low
_HIGHEST_AMPLITUDE = 1.0  # acts as a scalar factor, should be 0 to 1
_HIGHEST_DECIBEL = _amp_to_db(_LOWEST_AMPLITUDE, _HIGHEST_AMPLITUDE)


def vol_to_amp(vol: float) -> float:
    """Converts a volume level to an amplitude scalar factor.
    Input would range from 0 to HIGHEST_VOLUME (default:100).
    Output ranges from 0 to 1

    Furthermore, the output behaves similarly to the volume on a listening device,
    when setting the volume. If the max is 100% level, then 50% feels half as loud.

    Note: 0 is not absolutely silent, it is just extremely quiet, and is audible.
    Note 2: this volume is dependent on the system volume.
        Loudness = program volume * system volume (if in percentage)
    """
    db = (
        clip(vol, 0, HIGHEST_VOLUME, nomax=LIMIT_MAX_VOLUME)
        * _HIGHEST_DECIBEL
        / HIGHEST_VOLUME
    )
    amp = db_to_amp(db, _LOWEST_AMPLITUDE)
    return clip(amp, 0, _HIGHEST_AMPLITUDE, nomax=LIMIT_MAX_VOLUME)


def _parse_freq(value: Union[str, float]):
    if type(value) == str:
        if value in NOTES:
            return NOTES[value]
    if type(value) == int or type(value) == float:
        return float(value)
    return 0


def gen_wave(
    duration=1,
    volume=40,
    pitch: Union[str, float] = "A4",
    mod_f: Union[str, float] = 0,
    mod_k=0,
    amp_f: Union[str, float] = 0,
    amp_ka=0,
    amp_ac=1,
    cutoff=0.01,
    fs=8000,
):
    # Process frequencies, factors
    pitch = _parse_freq(pitch)
    mod_f = _parse_freq(mod_f)
    amp_f = _parse_freq(amp_f)

    # Convert volume using decibel underneath
    volume = vol_to_amp(volume)

    return _gen_wave(
        duration, volume, pitch, mod_f, mod_k, amp_f, amp_ka, amp_ac, cutoff, fs
    )


def _gen_wave(duration, volume, pitch, mod_f, mod_k, amp_f, amp_ka, amp_ac, cutoff, fs):
    n = int(duration * fs)
    t = [0 for i in range(n)]  # comprehension faster than append
    maximum = -(2**31)
    for i in range(0, n):
        x = i / fs
        # create carrier wave (float division is faster)
        c = 2 * math.pi * x * pitch
        # frequncy modulate
        m = mod_k * sin(2 * math.pi * mod_f * x)
        y = cos(c + m)
        # amplitude modulate
        a = amp_ac * (1 + (amp_ka * sin(2 * math.pi * amp_f * x)))
        y = y * a
        if maximum < (_abs := abs(y)):
            maximum = _abs
        # no append (which is marginally slow)
        t[i] = y

    # do volume and cutoff calculation
    max16 = 2**15 - 1
    cutoff = min(int(n / 2), int(fs * cutoff))
    k = (1 / 3) * (1 / math.log(2))
    for i in range(len(t)):
        # apply volume
        y = t[i] * volume

        # # apply cutoff
        if 0 <= i and i < cutoff:
            y *= math.log(i / cutoff * 7 + 1) * k
        elif n - cutoff <= i and i < n:
            j = n - i - 1
            y *= math.log(j / cutoff * 7 + 1) * k

        # pull down value to int16
        t[i] = clip(int(y * max16 / maximum), -32768, 32767, nomax=False)

    return array.array("h", t)


class Sound:
    def __init__(
        self,
        duration=1,
        volume=40,
        pitch="A4",
        mod_f=0,
        mod_k=0,
        amp_f=0,
        amp_ka=0,
        amp_ac=1,
        cutoff=0.01,
        fs=8000,
    ):
        self.player = None
        self._fs = fs  # needs a default value
        self.set_volume(volume)
        self.set_pitch(pitch)
        self.set_cutoff(cutoff)
        self.set_frequency_modulation(mod_f, mod_k)
        self.set_amplitude_modulation(amp_f, amp_ka, amp_ac)
        self.update_duration(duration, fs)

    def reset(self):
        """Fully resets the underlying audio of this Sound object.
        The sound must be stopped, or this will give unexpected behavior

        see Sound.reset_audio
        """
        return self.reset_audio()

    def reset_audio(self):
        """Fully resets the underlying audio data of this Sound object.
        The sound must be stopped, or this will give unexpected behavior
        """
        return self.update_audio(True)

    def append(self, other, spacing=0):
        """Takes the underlying audio data of another Sound object, other, and appends all of it
        to the underlying audio data of this Sound object.

        This does not alter any base attributes of this Sound object, and a 'reset' will undo these appends

        see Sound.append_sound
        """
        return self.append_sound(other, spacing)

    def append_sound(self, other, spacing=0):
        """Takes the underlying audio data of another Sound object, other, and appends all of it
        to the underlying audio data of this Sound object.

        This does not alter any base attributes of this Sound object, and a 'reset' will undo these appends
        """
        spacing = float(spacing)
        if spacing < 0:
            spacing = 0
        spacing_n = int(spacing * self._fs)

        if not self.is_playing():
            src = list(self.audio)
            dst = list(other.audio)
            spacer = [0 for i in range(spacing_n)]

            self.audio = array.array("h", src + spacer + dst)
        else:
            raise RuntimeError(
                "Cannot alter this sound object for repetition while playing this sound."
            )
        return self

    def repeat_sound(self, repeat_times=1, repeat_interval=0):
        """Alters the underlying audio data of this Sound object, such that the main sound will:
        - repeat equal to the value of repeat_times. It should be an integer value.
        - each time the original sound is repeated, there will be an interval of silence for 'repeat_interval' seconds.
            Expects either int or float value, of seconds for the interval. Default is 0 seconds.

        Explanation of Potential Usage:
        You may utilize the concept of BPM or "beats per minute" to help you with creating a tempo for your songs.
            If you want a sound repeated at 120bpm, that would be 2 times/sec, 0.5 seconds per sound played.
            If the original sound has duration 0.1 seconds, then the silence spacing would have to be 0.4 seconds, such that
            every sound starts playing every 0.5 seconds, matching 120bpm. The end of this repeated Sound object will be a
            sound playing for 0.1 seconds, and then no silence spacing afterwards. This is desired behavior. You can then perform
            a time.sleep(0.4) seconds before replaying this Sound object. BUT there is sometimes latency in "starting" a sound,
            so the time sleep may need to be smaller, such as 0.35 seconds instead.
        """
        repeat_times = int(repeat_times)  # This can cause an error, which is desired
        if repeat_times < 1:
            repeat_times = 1

        repeat_interval = float(repeat_interval)
        if repeat_times < 0:
            repeat_times = 0

        fs = self._fs
        interval_n = int(fs * repeat_interval)

        if not self.is_playing():
            src = list(self.audio)
            src_n = len(src)
            end_n = src_n * repeat_times + (repeat_times - 1) * interval_n
            spacer = [0 for i in range(interval_n)]
            n = src_n + interval_n
            arr = []
            tmp = src + spacer
            for i in range(end_n):
                arr.append(tmp[i % n])
            self.audio = array.array("h", arr)
        else:
            raise RuntimeError(
                "Cannot alter this sound object for repetition while playing this sound."
            )
        return self

    def set_volume(self, volume):
        """Set the volume level of this sound.
        **Must use Sound.update_audio() to apply all changes**

        Enter a value from (0-100).
        """
        self.volume = volume
        return self

    def set_pitch(self, pitch: Union[str, float]):
        """Set the pitch or frequency of this sound.
        **Must use Sound.update_audio() to apply all changes**

        Enter a Hertz value within audible human range:
            minimum: 0
            maximum: ~7500
        """
        self.pitch = pitch
        return self

    def set_cutoff(self, cutoff):
        """Set the 'cutoff', the duration of the lead-in and fade-out for each sound wave.
        **Must use Sound.update_audio() to apply all changes**

        Enter a value in seconds, default: 0.01s

        Notable Effects:
        a value of 0s may lead to a 'pop/crackle' noise at the beginning and end of a sound.
        a value greater than or equal to the duration (also <1s) may lead to a pulse-like noise.
        a value greater than or equal to duration (also >1s) may lead to a 'coming and going' feeling.
        """
        self.cutoff = cutoff
        return self

    def set_frequency_modulation(self, mod_f: Union[str, float], mod_k):
        """Set the frequency(mod_f) and strength(mod_k) of Frequency Modulation.
        This modulation gives special effects to your sounds.
        **Must use Sound.update_audio() to apply all changes**

        Enter a value of frequency for mod_f
        Enter any positive integer for mod_k, a multiplication factor

        Notable Effects:
        mod_f=0, mod_k=0 - no modulation. This is default settings.
        mod_f=(1-10Hz), mod_k=(1-10) - mild modulation, sounding wavy, possibly crackly.
        mod_f='A4', mod_k=(1-50) - increasing levels of graininess observed, with increasing k factor.

        *Swapping mod_f and the pitch leads to new effects*
        mod_f=pitch, pitch=1, mod_k=1 - Sounds like a pipe organ, where mod_f becomes the new pitch setting.
        """
        self.mod_f = mod_f
        self.mod_k = mod_k
        return self

    def set_amplitude_modulation(self, amp_f: Union[str, float], amp_ka, amp_ac):
        """Set the frequency(amp_f), ka factor(amp_ka), and ac factor(amp_ac) of Amplitude Modulation.
        Effect is most similar to 'vibrato' altering the volume in a wobbling sense.
        **Must use Sound.update_audio() to apply all changes**

        amp_ka - wobbling factor. 0 is no wobble. >0 provides wobble.
        amp_ac - factor to change strength of wobble overall. See Notable Effects to understand this.

        Constraints:
        (resultant volume is % of the set volume of this Sound object)
        highest % of volume = amp_ac * (1 + amp_ka)
        lowest  % of volume = amp_ac * (1 - amp_ka)

        Notable Effects:
        amp_f=1Hz - wobbles 1 time per second
        amp_f=10Hz - wobbles 10 times per second

        amp_ka=0, amp_ac=1 - no wobble. The default settings.
        amp_ka=1, amp_ac=0.5 - alternates volume from 100% to 0% according to amp_f frequency.
        amp_ka=0.5, amp_ac=0.5 - alternates volume from 25% to 75% according to amp_f frequency.
        """
        self.amp_f = amp_f
        self.amp_ka = amp_ka
        self.amp_ac = amp_ac
        return self

    def update_duration(self, duration, fs: int = None):
        """Change the duration of this Sound (seconds).
        Cannot change duration of currently playing sounds.

        Only affects the next played sound.

        fs - Sample rate of sound wave. Default 8000 as lowest.
            Increased 'quality' with higher rate.
        """
        if fs is not None:
            self._fs = fs
        self._duration = duration

        if not self.is_playing():
            self.update_audio(True)
        else:
            raise RuntimeError(
                "Cannot change duration or sample rate while playing sound."
            )
        return self

    def update_audio(self, overwrite: bool = False):
        """Updates the audio to be played, based on current Sound attributes.

        - if overwrite=False and is_playing()==True, the playing audio will be updated
        - if overwrite=True and is_playing()==True, changes are present only in next play()
        """
        arr = gen_wave(
            self._duration,
            self.volume,
            self.pitch,
            self.mod_f,
            self.mod_k,
            self.amp_f,
            self.amp_ka,
            self.amp_ac,
            self.cutoff,
            self._fs,
        )
        if not overwrite:
            for i in range(min(len(self.audio), len(arr))):
                self.audio[i] = arr[i]
        else:
            self.audio = arr
        return self

    def alter_wave(self, func: Callable[[float, int], int]):
        """Apply a function to change the currently playing/prepared audio wave.

        func is of the format: func(x:float, y:int16) -> y:int16

        Given an xy-coordinate plane with the sound wave being centered on y=0,
        x is time in seconds, and y is amplitude in the range [-32768, 32767]


        """
        for i in range(len(self.audio)):
            # func(x:float, y:int16) -> y:int16
            self.audio[i] = clip(func(i / self._fs, self.audio[i]), -32768, 32767)
        return self

    def play(self):
        self.stop()
        self.player = sa.play_buffer(self.audio, 1, 2, self._fs)
        return self

    def stop(self):
        if self.is_playing():
            self.player.stop()
        return self

    def is_playing(self) -> bool:
        return self.player is not None and self.player.is_playing()

    def wait_done(self):
        if self.is_playing():
            self.player.wait_done()
        return self

    def __repr__(self):
        return f"Sound({self.pitch}, {self._duration}secs, {self.volume}%, {self.mod_f}mod)"


class Song(list):
    """Creates a special player object, that can play Sound objects
     quickly for long periods of time.

    Example Usage:

    s0 = Song.create_silence(seconds=0.5)
    s1 = Sound(duration=1, pitch="A4")
    s2 = Sound(duration=1, pitch="B4")

    song = Song([s1, s0, s2, s0])
    song *= 4 # repeat the song 4 times over

    song.compile() # Slow process, several seconds latency

    song.play() # Faster, ~0.7 seconds latency
    time.sleep(song.duration)
    song.stop()
    """

    MIN_VOLUME, MAX_VOLUME = -32_767, +32_767

    @staticmethod
    def create_silence(seconds=1):
        """A helper method to create a special Sound object
        containing silence of given duration.
        """

        core = Sound(duration=1)
        core.audio = array.array("h", [0 for i in range(int(core._fs * seconds))])

        return core

    def __init__(self, sounds=()):
        """Creates a Song with that plays silence for 1 second by default.

        Can be initialized with a list of existing sounds.
        This is optional.

        Sounds can be added with Song.append(sound)
        """
        super().__init__()
        self.core = self.create_silence(1)  # Default silence
        self.duration = self.core._duration

        self.extend(sounds)

    def append(self, obj):
        """Add a Sound object to this Song.

        Must be of type Sound."""
        if not isinstance(obj, Sound):
            raise ValueError("Cannot append objects that are not type Sound")
        super().append(obj)

    def extend(self, ls):
        """Adds all the Sounds of ls to this Song.
        This can work for lists of Sounds, any iterable containing Sounds,
        or another Song.

        Ignores non-Sound objects.
        """
        for el in ls:
            if isinstance(el, Sound):
                self.append(el)

    def compile(self):
        """Compiles the appended sounds to create the song.

        After this is set, then it can be played using Song.play()
        """
        sounds = [s for s in self if isinstance(s, Sound)]
        self.duration = sum([s._duration for s in sounds])
        self._samples = sum([len(s.audio) for s in sounds])
        self.core = Sound(duration=1)
        self.core.audio = array.array("h", [0 for i in range(int(self._samples))])
        ptr = 0
        for s in sounds:
            n = len(s.audio)
            for i in range(n):
                self.core.audio[min(ptr, self._samples - 1)] = s.audio[i]
                ptr += 1

    def play(self):
        """Starts the Song. It plays silence by default.

        Has latency on startup. Will stop by itself after the
            Song duration has ended (defined in init)

        If Song.play_sound(s1) was done already, then Song.start()
            will play the given sound s1 to begin with.
        """
        self.core.play()

    def stop(self):
        """Stops the Song. Keeps the last sound that was
        used in Song.play_sound(s1)

        """
        self.core.stop()

    def is_playing(self):
        """Returns True if the Song is active.

        Active means that it would play sound, when the
            Song.play_sound(s1) function is called.
        """
        return self.core.is_playing()

    def wait_done(self):
        """Uses a while-loop to keep checking until the song is done playing.

        Reliable, un-interruptible.
        """
        while self.is_playing():
            time.sleep(0.01)

    def sleep_done(self):
        """Uses a time.sleep to wait for the duration of the song.

        Interruptable, less reliable.
        """
        time.sleep(self.duration)

    def __del__(self):
        self.stop()


NOTES = {
    "C0": 16.35,
    "D0": 18.35,
    "E0": 20.60,
    "F0": 21.83,
    "G0": 24.50,
    "A0": 27.50,
    "B0": 30.87,
    "C1": 32.70,
    "D1": 36.71,
    "E1": 41.20,
    "F1": 43.65,
    "G1": 49.00,
    "A1": 55.00,
    "B1": 61.74,
    "C2": 65.41,
    "D2": 73.42,
    "E2": 82.41,
    "F2": 87.31,
    "G2": 98.00,
    "A2": 110.00,
    "B2": 123.47,
    "C3": 130.81,
    "D3": 146.83,
    "E3": 164.81,
    "F3": 174.61,
    "G3": 196.00,
    "A3": 220.00,
    "B3": 246.94,
    "C4": 261.63,
    "D4": 293.66,
    "E4": 329.63,
    "F4": 349.23,
    "G4": 392.00,
    "A4": 440.00,
    "B4": 493.88,
    "C5": 523.25,
    "D5": 587.33,
    "E5": 659.25,
    "F5": 698.46,
    "G5": 783.99,
    "A5": 880.00,
    "B5": 987.77,
    "C6": 1046.50,
    "D6": 1174.66,
    "E6": 1318.51,
    "F6": 1396.91,
    "G6": 1567.98,
    "A6": 1760.00,
    "B6": 1975.53,
    "C7": 2093.00,
    "D7": 2349.32,
    "E7": 2637.02,
    "F7": 2793.83,
    "G7": 3135.96,
    "A7": 3520.00,
    "B7": 3951.07,
    "C8": 4186.01,
    "D8": 4698.63,
    "E8": 5274.04,
    "F8": 5587.65,
    "G8": 6271.93,
    "A8": 7040.00,
    "B8": 7902.13,
    "C#0": 17.32,
    "Db0": 17.32,
    "D#0": 19.45,
    "Eb0": 19.45,
    "F#0": 23.12,
    "Gb0": 23.12,
    "G#0": 25.96,
    "Ab0": 25.96,
    "A#0": 29.14,
    "Bb0": 29.14,
    "C#1": 34.65,
    "Db1": 34.65,
    "D#1": 38.89,
    "Eb1": 38.89,
    "F#1": 46.25,
    "Gb1": 46.25,
    "G#1": 51.91,
    "Ab1": 51.91,
    "A#1": 58.27,
    "Bb1": 58.27,
    "C#2": 69.30,
    "Db2": 69.30,
    "D#2": 77.78,
    "Eb2": 77.78,
    "F#2": 92.50,
    "Gb2": 92.50,
    "G#2": 103.83,
    "Ab2": 103.83,
    "A#2": 116.54,
    "Bb2": 116.54,
    "C#3": 138.59,
    "Db3": 138.59,
    "D#3": 155.56,
    "Eb3": 155.56,
    "F#3": 185.00,
    "Gb3": 185.00,
    "G#3": 207.65,
    "Ab3": 207.65,
    "A#3": 233.08,
    "Bb3": 233.08,
    "C#4": 277.18,
    "Db4": 277.18,
    "D#4": 311.13,
    "Eb4": 311.13,
    "F#4": 369.99,
    "Gb4": 369.99,
    "G#4": 415.30,
    "Ab4": 415.30,
    "A#4": 466.16,
    "Bb4": 466.16,
    "C#5": 554.37,
    "Db5": 554.37,
    "D#5": 622.25,
    "Eb5": 622.25,
    "F#5": 739.99,
    "Gb5": 739.99,
    "G#5": 830.61,
    "Ab5": 830.61,
    "A#5": 932.33,
    "Bb5": 932.33,
    "C#6": 1108.73,
    "Db6": 1108.73,
    "D#6": 1244.51,
    "Eb6": 1244.51,
    "F#6": 1479.98,
    "Gb6": 1479.98,
    "G#6": 1661.22,
    "Ab6": 1661.22,
    "A#6": 1864.66,
    "Bb6": 1864.66,
    "C#7": 2217.46,
    "Db7": 2217.46,
    "D#7": 2489.02,
    "Eb7": 2489.02,
    "F#7": 2959.96,
    "Gb7": 2959.96,
    "G#7": 3322.44,
    "Ab7": 3322.44,
    "A#7": 3729.31,
    "Bb7": 3729.31,
    "C#8": 4434.92,
    "Db8": 4434.92,
    "D#8": 4978.03,
    "Eb8": 4978.03,
    "F#8": 5919.91,
    "Gb8": 5919.91,
    "G#8": 6644.88,
    "Ab8": 6644.88,
    "A#8": 7458.62,
    "Bb8": 7458.62,
}

_note_order = {
    "b": "x",
    "": "y",
    "#": "z",
    "C": "0",
    "D": "1",
    "E": "2",
    "F": "3",
    "G": "4",
    "A": "5",
    "B": "6",
}

NOTE_NAMES = sorted(
    list(NOTES.keys()), key=lambda x: x[-1] + _note_order[x[0]] + _note_order[x[1:-1]]
)


def preload_all_pitches(
    duration=1,
    volume=40,
    mod_f=0,
    mod_k=0,
    amp_f=0,
    amp_ka=0,
    amp_ac=1,
    cutoff=0.01,
    fs=8000,
):
    return {
        key: Sound(
            pitch=key,
            duration=duration,
            volume=volume,
            mod_f=mod_f,
            mod_k=mod_k,
            amp_f=amp_f,
            amp_ka=amp_ka,
            amp_ac=amp_ac,
            cutoff=cutoff,
            fs=fs,
        )
        for key in NOTE_NAMES
    }


def save_all_pitches_file(sounds, filename="sounds"):
    path = os.path.join(
        os.path.dirname(os.path.realpath(__file__)), str(filename) + ".pickle"
    )
    with open(path, "rb") as f:
        pickle.dump(sounds, f)


def load_all_pitches_file(filename="sounds"):
    path = os.path.join(
        os.path.dirname(os.path.realpath(__file__)), str(filename) + ".pickle"
    )
    with open(path, "rb") as f:
        return pickle.load(f)


SAMPLE_RATES = [
    8000,
    11025,
    16000,
    22050,
    24000,
    32000,
    44100,
    48000,
    88200,
    96000,
    192000,
]


def _test1():
    a = Sound()  # Basic 1sec A4 Note at 20% vol
    a.play()
    input("Press any button to continue to new pitch...")
    b = Sound(pitch="C4")  # Now a C4 note
    b.play()
    input("Press any button to continue to reuse and play two notes...")
    a.play()
    b.play()
    input("Press any button to continue to play strange notes...")
    c = Sound(mod_f=10, mod_k=10)
    c.play()
    input("Press any button to continue to play a different basic sound...")
    # swap mod_f and pitch for new effect
    d = Sound(mod_f="A4", mod_k=1, pitch=1)
    d.play()
    input("Press any button to continue to stop...")


def _test_vol1():
    Sound(volume=0.001).play().wait_done()
    while (
        (ans := input("Enter volume (100-0): "))
        and ans.count(".") <= 1
        and ans.replace(".", "").isnumeric()
    ):
        Sound(volume=float(ans)).play().wait_done()


if __name__ == "__main__":
    _test_vol1()
</file>

<file path=".gitignore">
# __pycache__
*.pyc
.idea/**
</file>

<file path="track_testing.py">
from utils.brick import wait_ready_sensors, Motor
import time

MOTOR_DPS_CONST = 60
SPEED_MODIFIER = 1

MOTOR_DPS = MOTOR_DPS_CONST * SPEED_MODIFIER

motor_left = Motor("D")
motor_right = Motor("A")

wait_ready_sensors()


def turn_90():
    print("Turning!")
    motor_left.reset_encoder()
    motor_right.reset_encoder()

    motor_left.set_dps(MOTOR_DPS)
    motor_right.set_dps(-MOTOR_DPS)

    time.sleep(2 / SPEED_MODIFIER)

    reset_motors()
    return


def advance_one():
    print("advancing one field")
    motor_left.set_dps(MOTOR_DPS)
    motor_right.set_dps(MOTOR_DPS)

    time.sleep(2 / SPEED_MODIFIER)

    reset_motors()


def main():
    print("Attempting Turn!")
    turn_90()
    time.sleep(5)
    turn_90()


def reset_motors():
    motor_left.set_power(0)
    motor_right.set_power(0)


if __name__ == "__main__":
    print("Start")
    try:
        main()
    except Exception:
        reset_motors()
        print("whoops!")
</file>

<file path="main.py">
import logging
import time
from utils.brick import Motor, EV3ColorSensor, EV3UltrasonicSensor, TouchSensor, wait_ready_sensors

from src.drive_system import DriveSystem
from src.sensor_system import SensorSystem
from src.fire_extinguisher import FireExtinguisher
from src.navigation import Navigation
from src.siren_controller import SirenController
from src.mission_control import MissionControl
from src.constants import COLOR_RED, HALLWAY_PATH, LEFT_MOTOR_PORT, RIGHT_MOTOR_PORT, DROPPER_MOTOR_PORT, \
    LEFT_COLOR_PORT, RIGHT_COLOR_PORT, ULTRASONIC_PORT, TOUCH_PORT, EAST, SOUTH, WEST, NORTH

# Configure logging for the main module
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()],
)

logger = logging.getLogger(__name__)


class FirefighterRobot:
    """Main robot class that integrates all components."""

    def __init__(self):
        # Initialize hardware components
        logger.info("Initializing Robot")
        self.left_motor = Motor(LEFT_MOTOR_PORT)
        self.right_motor = Motor(RIGHT_MOTOR_PORT)
        self.dropper_motor = Motor(DROPPER_MOTOR_PORT)

        # Initialize sensors
        self.left_color = EV3ColorSensor(LEFT_COLOR_PORT)
        self.right_color = EV3ColorSensor(RIGHT_COLOR_PORT)
        self.ultrasonic = EV3UltrasonicSensor(ULTRASONIC_PORT)
        self.touch_sensor = TouchSensor(TOUCH_PORT)

        # Create sub-systems
        wait_ready_sensors()

        self.drive_system = DriveSystem(self.left_motor, self.right_motor)
        self.sensor_system = SensorSystem(
            self.left_color, self.right_color, self.ultrasonic, self.touch_sensor
        )
        self.extinguisher = FireExtinguisher(self.dropper_motor)
        self.siren = SirenController()
        self.navigation = Navigation(self.drive_system, self.sensor_system)

        # Init mission control and provide it the subsystems
        self.mission_control = MissionControl(
                self.drive_system,
                self.sensor_system,
                self.navigation,
                self.extinguisher,
                self.siren
            )

        self.initialized = True

        logger.info("FirefighterRobot fully initialized and ready")

    def run_mission(self):
        """Execute the firefighting mission."""
        logger.info("Starting firefighter mission")

        try:
            self.mission_control.run_mission()
        except KeyboardInterrupt:
            logger.info("Mission interrupted by user")
        except Exception as e:
            logger.error(f"Error during mission: {e}")
        finally:
            self.mission_control.stop_mission()

    def calibration_test(self):
        """Run tests of basic components."""
        logger.info("Starting calibration tests")

        try:
            # Test siren
            logger.info("Testing siren")
            self.siren.start()

            # Test sensors (before moving so we can put something down)
            logger.info("Testing sensors")
            left_color = self.sensor_system.get_color_left()
            right_color = self.sensor_system.get_color_right()
            logger.info(f"Color readings - Left: {left_color}, Right: {right_color}")

            # Test fire detection and cube dropping

            if left_color == COLOR_RED:
                self.mission_control.drop_on_sensor("LEFT")
            elif right_color == COLOR_RED:
                self.mission_control.drop_on_sensor("RIGHT")

            time.sleep(1)

            # Test distance sensor if available
            if self.sensor_system.ultrasonic:
                distance = self.sensor_system.get_wall_distance()
                logger.info(f"Distance to wall: {distance} cm")

            time.sleep(3)

            self.siren.stop()
            logger.info("Calibration tests complete")

        except Exception as e:
            logger.error(f"Error during calibration: {e}")
        finally:
            # Clean shutdown
            self.drive_system.stop()
            self.siren.stop()

    def run_simple_path(self):
        """Run a simple path to test navigation."""
        logger.info("Running simple test path")

        try:
            # Start siren
            self.siren.start()



            # Navigate first few steps
            for x, y in HALLWAY_PATH[1:4]:  # Just the first few steps
                logger.info(f"Navigating to ({x}, {y})")
                self.navigation.navigate_to(x, y)

            # Return to start
            logger.info("Returning to start")
            self.navigation.navigate_to(0, 0)

            # Stop siren
            self.siren.stop()

        except Exception as e:
            logger.error(f"Error during test path: {e}")
        finally:
            self.drive_system.stop()
            self.siren.stop()

    def test_nineties(self):
        """Test 90-degree turning capabilities."""
        logger.info("Testing 90-degree turns")
        try:
            self.drive_system.turn(EAST)
            time.sleep(1)
            self.drive_system.turn(SOUTH)
            time.sleep(1)
            self.drive_system.turn(WEST)
            time.sleep(1)
            self.drive_system.turn(SOUTH)
            time.sleep(1)
            self.drive_system.turn(EAST)
            time.sleep(1)
            self.drive_system.turn(NORTH)
        except Exception as e:
            logger.error(f"Error during turn testing: {e}")
        finally:
            self.drive_system.stop()


def main():
    """Main entry point for the firefighter robot mission."""
    robot = FirefighterRobot()

    try:
        robot.run_mission()
    except KeyboardInterrupt:
        logger.info("Mission interrupted by user")
    finally:
        # Stop everything
        if robot:
            robot.drive_system.stop()
            robot.siren.stop()


def calibration_testing():
    """Test basic robot functionality."""
    robot = FirefighterRobot()
    robot.calibration_test()


def simple_path_test():
    """Run a simple navigation test."""
    robot = FirefighterRobot()
    robot.run_simple_path()


def testing_nineties():
    """Test robot turning capabilities."""
    robot = FirefighterRobot()
    robot.test_nineties()


if __name__ == "__main__":
    main()
</file>

<file path="structured_main.py">
import threading
from utils.brick import Motor, EV3ColorSensor, EV3UltrasonicSensor, TouchSensor
import time
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()],
)
logger = logging.getLogger(__name__)


class MissionControl:
    """Manages the overall mission execution and state."""

    def __init__(self, drive, sensors, navigation, extinguisher, siren):
        self.drive = drive
        self.sensors = sensors
        self.navigation = navigation
        self.extinguisher = extinguisher
        self.siren = siren

        # Mission state
        self.mission_running = False
        self.emergency_stop_thread = None
        self.fires_detected = 0
        self.mission_start_time = None

    def start_emergency_monitor(self):
        """Start monitoring for emergency stop signal."""
        self.emergency_stop_thread = threading.Thread(
            target=self._monitor_emergency_stop
        )
        self.emergency_stop_thread.daemon = True
        self.emergency_stop_thread.start()
        logger.info("Emergency stop monitor started")

    def _monitor_emergency_stop(self):
        """Background thread for emergency stop monitoring."""
        while self.mission_running:
            if self.sensors.is_emergency_pressed():
                logger.warning("EMERGENCY STOP ACTIVATED")
                self.stop_mission()
                break
            time.sleep(0.1)

    def navigate_hallway(self):
        """Navigate through the hallway to the entrance."""
        logger.info("Starting hallway navigation")

        for x, y in HALLWAY_PATH[1:]:  # Skip first position
            if not self.mission_running:
                break

            logger.info(f"Navigating to checkpoint ({x}, {y})")
            self.navigation.navigate_to(x, y)

            # Check time limit
            if self._check_time_limit():
                break

        elapsed_time = time.time() - self.mission_start_time

        if elapsed_time > EXPECTED_TIME_TO_BURNING_ROOM:
            logger.warning(
                f"Navigation to entrance took longer than expected: {elapsed_time:.1f}s vs {EXPECTED_TIME_TO_BURNING_ROOM}s expected"
            )
        # Orient to face entrance
        self.drive.turn(NORTH)

        # Check if at entrance
        is_at_entrance = (
            self.drive.position[0] == ENTRANCE[0]
            and self.drive.position[1] == ENTRANCE[1]
        )

        if is_at_entrance:
            logger.info("Reached entrance position")
            return True
        else:
            logger.warning(
                f"Failed to reach entrance, current position: {self.drive.position}"
            )
            return False

    def enter_burning_room(self):
        """Enter the burning room if at entrance and orange line detected."""
        # First try to find and align with the orange entrance line
        found_orange, _ = self.sensors.check_for_entrance()

        if not found_orange:
            logger.info("Orange line not immediately visible, attempting to align")
            aligned = self.navigation.align_with_entrance()

            if not aligned:
                logger.warning(
                    "Failed to align with orange entrance, will attempt entry anyway"
                )

        # Enter room (once aligned or after attempting alignment)
        logger.info("Entering burning room")
        self.drive.advance_blocks(1)  # Move one block north to enter

        # Verify we're in the burning room
        room_type = self.navigation.identify_room()
        logger.info(f"Entered room identified as: {room_type}")

        if room_type == "burning room":
            logger.info("Successfully entered burning room")
            return True
        elif room_type == "avoid room":
            raise Exception(
                "For some reason it thinks we are in the avoid room. Color sensors!?"
            )
            logger.warning("Entered wrong room (avoid room)! Exiting immediately")
            # Return to hallway
            self.drive.turn(NORTH)
            self.drive.advance_blocks(1)
            return False
        else:
            logger.warning(f"Room type uncertain: {room_type}. Proceeding with caution")
            # Assume we're in the burning room but log the uncertainty
            return True

    def sweep_burning_room(self):
        """Search the burning room for fires and extinguish them."""
        logger.info("Starting systematic room sweep")

        for x, y in BURNING_ROOM_SWEEP:
            if not self.mission_running:
                break

            logger.info(f"Sweeping position ({x}, {y})")
            self.navigation.navigate_to(x, y)

            # Check for fire
            if self.sensors.check_for_fire():
                logger.info(f"Fire detected at position {self.drive.position}")
                self.fires_detected += 1

                # TODO: Move to drop on top of the relevant sensor
                # Drop
                self.extinguisher.drop_cube()
                # Wait one second (so we can move it out of the way and continue)

                # If we've found both fires, we can stop
                if self.extinguisher.get_fires_extinguished() >= 2:
                    logger.info("Both fires extinguished, ending sweep")
                    break

            # Check time limit
            if self._check_time_limit():
                break

        logger.info(
            f"Room sweep complete. Fires found: {self.fires_detected}, extinguished: {self.extinguisher.get_fires_extinguished()}"
        )
        return self.extinguisher.get_fires_extinguished() > 0

    def return_to_base(self):
        """Navigate back to the starting point."""
        logger.info("Beginning return journey to base")

        # First exit the room if needed
        if self.drive.position[1] >= 3:  # If in burning room (row 3 or 4)
            logger.info("Exiting burning room")
            self.navigation.navigate_to(BURNING_ROOM_ENTRY[0], BURNING_ROOM_ENTRY[1])
            self.navigation.navigate_to(ENTRANCE[0], ENTRANCE[1])

        # Follow return path
        for x, y in RETURN_PATH:
            if not self.mission_running:
                break

            # Skip if already at this position
            if self.drive.position[0] == x and self.drive.position[1] == y:
                continue

            logger.info(f"Returning via checkpoint ({x}, {y})")
            self.navigation.navigate_to(x, y)

            # Check time limit
            if self._check_time_limit():
                break

        # Check if successfully returned to base
        is_at_base = self.drive.position[0] == 0 and self.drive.position[1] == 0

        if is_at_base:
            logger.info("Successfully returned to base station (0,0)")
            return True
        else:
            logger.warning(
                f"Failed to return to base, stopped at {self.drive.position}"
            )
            return False

    def _check_time_limit(self):
        """Check if mission time limit (3 minutes) has been reached."""
        if self.mission_start_time is None:
            return

        elapsed_time = time.time() - self.mission_start_time
        if elapsed_time >= 180:  # 3 minutes
            logger.warning("Mission time limit (3 minutes) reached!")
            return True
        return False

    def stop_mission(self):
        """Stop the mission and all activities."""
        logger.info("Stopping mission")
        self.mission_running = False
        self.drive.stop()
        self.siren.stop()

    def drop_on_sensor(self, sensor: str):
        ROTATION_SECONDS = 0.9
        FORWARD_MOVE = 0.5
        if sensor == "RIGHT":
            self.drive.turn_slightly_right(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE + 0.1)
            self.extinguisher.drop_cube()
            self.drive.move_backward_slightly(FORWARD_MOVE)
            self.drive.turn_slightly_left(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE - 0.1)
        else:
            self.drive.turn_slightly_left(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE + 0.1)
            self.extinguisher.drop_cube()
            self.drive.move_backward_slightly(FORWARD_MOVE)
            self.drive.turn_slightly_right(ROTATION_SECONDS)
            self.drive.move_forward_slightly(FORWARD_MOVE - 0.1)

    def run_mission(self):
        """Execute the full firefighting mission."""
        # Initialize mission
        self.mission_running = True
        self.mission_start_time = time.time()
        self.fires_detected = 0

        try:
            # Start emergency monitor
            self.start_emergency_monitor()

            # Start siren
            self.siren.start()

            # Navigate through hallway to entrance
            if self.navigate_hallway():
                # At entrance, try to enter burning room
                if self.enter_burning_room():
                    # In burning room, stop siren
                    self.siren.stop()

                    # Search for and extinguish fires
                    # TODO: Actually Sweep the Burning Room
                    # success = self.sweep_burning_room()

                    # Return to base
                    self.return_to_base()
                else:
                    logger.error("Failed to enter burning room")
            else:
                logger.error("Failed to reach entrance")

            # Mission complete
            elapsed_time = time.time() - self.mission_start_time
            logger.info(f"Mission completed in {elapsed_time:.1f} seconds")
            logger.info(
                f"Fires detected: {self.fires_detected}, extinguished: {self.extinguisher.get_fires_extinguished()}"
            )

        except Exception as e:
            logger.error(f"Error during mission: {e}")
        finally:
            # Ensure proper shutdown
            self.stop_mission()


class FirefighterRobot:
    """Main robot class that integrates all components."""

    def __init__(self):
        left_motor = Motor("B")
        right_motor = Motor("D")
        dropper_motor = Motor("A")
        left_color = EV3ColorSensor(1)
        right_color = EV3ColorSensor(2)
        ultrasonic = EV3UltrasonicSensor(3)
        touch_sensor = TouchSensor(4)

        # Create sub-systems
        self.drive_system = DriveSystem(left_motor, right_motor)
        self.sensor_system = SensorSystem(
            left_color, right_color, ultrasonic, touch_sensor
        )
        self.extinguisher = FireExtinguisher(dropper_motor)

        self.siren = SirenController()

        self.navigation = Navigation(self.drive_system, self.sensor_system)

        self.mission_control = MissionControl(
            self.drive_system,
            self.sensor_system,
            self.navigation,
            self.extinguisher,
            self.siren,
        )

        logger.info("FirefighterRobot fully initialized and ready")

    def run_mission(self):
        """Execute the firefighting mission."""
        self.mission_control.run_mission()

    def calibration_test(self):
        """Run tests of basic components."""
        logger.info("Starting calibration tests")

        try:
            # Test siren
            logger.info("Testing siren")
            self.siren.start()


            # Test sensors (before moving so we can put something down)
            logger.info("Testing sensors")
            left_color = self.sensor_system.get_color_left()
            right_color = self.sensor_system.get_color_right()
            logger.info(f"Color readings - Left: {left_color}, Right: {right_color}")

            if left_color == COLOR_RED:
                self.mission_control.drop_on_sensor("LEFT")
            elif right_color == COLOR_RED:
                self.mission_control.drop_on_sensor("RIGHT")

            time.sleep(1)

            if self.sensor_system.ultrasonic:
                distance = self.sensor_system.get_wall_distance()
                logger.info(f"Distance to wall: {distance} cm")

            time.sleep(3)

            self.siren.stop()
            logger.info("Calibration tests complete")

        except Exception as e:
            logger.error(f"Error during calibration: {e}")
        finally:
            # Clean shutdown
            self.drive_system.stop()
            self.siren.stop()

    def run_simple_path(self):
        """Run a simple path to test navigation."""
        logger.info("Running simple test path")

        try:
            # Start siren
            self.siren.start()

            # Navigate first few steps
            for x, y in HALLWAY_PATH[1:4]:  # Just the first few steps
                logger.info(f"Navigating to ({x}, {y})")
                self.navigation.navigate_to(x, y)

            # Return to start
            logger.info("Returning to start")
            self.navigation.navigate_to(0, 0)

            # Stop siren
            self.siren.stop()

        except Exception as e:
            logger.error(f"Error during test path: {e}")
        finally:
            self.drive_system.stop()
            self.siren.stop()

    def test_nineties(self):
        logger.info("testing 90s")
        try:
            self.drive_system.turn("EAST")
            time.sleep(1)
            self.drive_system.turn("SOUTH")
            time.sleep(1)
            self.drive_system.turn("WEST")
            time.sleep(1)
            self.drive_system.turn("SOUTH")
            time.sleep(1)
            self.drive_system.turn("EAST")
            time.sleep(1)
            self.drive_system.turn("NORTH")
        except Exception as e:
            logger.error(f"Error during test path: {e}")
        finally:
            self.drive_system.stop()

def main():
    """Main entry point for the firefighter robot mission."""
    robot = FirefighterRobot()

    try:
        robot.run_mission()
    except KeyboardInterrupt:
        logger.info("Mission interrupted by user")
    finally:
        # Stop everything
        if robot:
            robot.drive_system.stop()
            robot.siren.stop()


def calibration_testing():
    """Test basic robot functionality."""
    robot = FirefighterRobot()
    robot.calibration_test()


def simple_path_test():
    """Run a simple navigation test."""
    robot = FirefighterRobot()
    robot.run_simple_path()

def testing_nineties():
    """ Turns the robot a couple of times."""
    robot = FirefighterRobot()
    robot.test_nineties()

if __name__ == "__main__":
    # main()
    calibration_testing()
    # simple_path_test()
</file>

</files>
